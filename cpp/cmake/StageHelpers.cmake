# ---------------------------------------------------------------------------
# cmake/StageHelpers.cmake
#
# Purpose: Provides a consistent API for staging project artifacts.
#
# This module defines a set of functions that abstract the process of copying
# build artifacts (headers, libraries, executables) into the unified staging
# directory (`${PYLABHUB_STAGING_DIR}`). This ensures that all components of
# the project follow the same conventions for creating a runnable, testable
# layout.
#
# This script provides the following functions:
#
# - pylabhub_stage_headers(...)
#   Schedules third-party header files or directories to be copied to the
#   staging area's `include/` directory.
#
# - pylabhub_stage_executable(...)
#   Schedules an executable target to be copied to a destination in the
#   staging area.
#
# - pylabhub_get_library_staging_commands(...)
#   Generates a list of commands to stage a library target. It correctly
#   handles platform differences (e.g., DLLs vs. .so) and separates runtime
#   from link-time artifacts. This function is intended for use with our own
#   project's targets via `add_custom_target`.
#
# - pylabhub_stage_libraries(...)
#   A convenience wrapper that schedules third-party library artifacts to be
#   copied to the staging area. It attaches commands directly to the global
#   `stage_third_party_deps` target.
#
# These functions rely on variables being set by the top-level `CMakeLists.txt`:
#
# - PYLABHUB_STAGING_DIR: The root directory for all staged artifacts.
#
# And on custom targets defined in the build system:
#
# - stage_third_party_deps: The global custom target to which staging
#   commands for third-party libraries are attached.
# ---------------------------------------------------------------------------
#
cmake_minimum_required(VERSION 3.29)

# --- pylabhub_stage_headers ---
#
# Schedules the copying of header files or directories to the staging area.
# This function is specifically designed for staging third-party headers by
# attaching copy commands to the `stage_third_party_deps` target.
#
# Usage:
#   pylabhub_stage_headers(
#     [TARGETS <target1> ...]       # Stage headers from the INTERFACE_INCLUDE_DIRECTORIES of these targets.
#     [DIRECTORIES <dir1> ...]      # Stage headers from these explicit directories.
#     SUBDIR <subdir_name>          # The subdirectory within `${PYLABHUB_STAGING_DIR}/include` to copy to. (Required)
#     [ATTACH_TO <target_name>]     # The custom target to attach commands to. (Default: stage_third_party_deps)
#   )
#
# Design Notes:
#   This function is primarily for third-party headers, hence the default ATTACH_TO target.
#
#   Staging headers from a target's `INTERFACE_INCLUDE_DIRECTORIES` is complex
#   because the property can contain a generator expression that expands to a
#   list of paths at build time. To handle this robustly, this function uses
#   `file(GENERATE)` to create a small CMake script. This script is executed at
#   build time (via `add_custom_command`), where it can correctly resolve the
#   generator expression, iterate over the resulting list of directories, and
#   copy each one.
#
function(pylabhub_stage_headers)
  set(options "")
  set(oneValueArgs "SUBDIR;ATTACH_TO;EXTERNAL_PROJECT_DEPENDENCY")
  set(multiValueArgs "TARGETS;DIRECTORIES")
  cmake_parse_arguments(ARG "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})

  if(NOT ARG_ATTACH_TO)
    set(ARG_ATTACH_TO "stage_third_party_deps")
  endif()

  if(NOT ARG_SUBDIR)
    message(STATUS " ** pylabhub_stage_headers prepare staging to ${PYLABHUB_STAGING_DIR}/include")
    set(DEST_DIR "${PYLABHUB_STAGING_DIR}/include")
  else()
    message(STATUS " ** pylabhub_stage_headers prepare staging to ${PYLABHUB_STAGING_DIR}/include/${ARG_SUBDIR}")
    set(DEST_DIR "${PYLABHUB_STAGING_DIR}/include/${ARG_SUBDIR}")
  endif()

  # Stage headers from explicit directories
  foreach(DIR IN LISTS ARG_DIRECTORIES)
    # Create a unique name for the script and marker file
    string(RANDOM LENGTH 8 SCRIPT_ID)
    set(SCRIPT_PATH "${CMAKE_CURRENT_BINARY_DIR}/stage_headers_scripts/stage_dir_${SCRIPT_ID}.cmake")

    string(MAKE_C_IDENTIFIER "stage_headers_dir_${SCRIPT_ID}_marker" _marker_name)
    set(STAGING_MARKER_FILE "${CMAKE_CURRENT_BINARY_DIR}/.staging_markers/${_marker_name}")

    # Content of the build-time script
    set(SCRIPT_CONTENT "
# --- This script is generated by pylabhub_stage_headers ---
set(SOURCE_DIR \"${DIR}\")
set(DEST_DIR \"${DEST_DIR}\")
message(STATUS \"[pylabhub_stage_headers customed script] checking source directory \${SOURCE_DIR}.....\")
if(NOT EXISTS \"\${SOURCE_DIR}\")
    message(SEND_ERROR \"Source directory '\${SOURCE_DIR}' for staging does not exist.\")
    return()
endif()

# Find all files recursively within the source directory
file(GLOB_RECURSE ALL_FILES
    LIST_DIRECTORIES false
    FOLLOW_SYMLINKS
    \"\${SOURCE_DIR}/*.h\"
    \"\${SOURCE_DIR}/*.hpp\"
)

# Ensure destination directory exists at execution time
execute_process(COMMAND \"${CMAKE_COMMAND}\" \"-E\" \"make_directory\" \"\${DEST_DIR}\")

foreach(FILE \${ALL_FILES})
    # Get the path of the file relative to the source directory
    string(REPLACE \"\${SOURCE_DIR}/\" \"\" REL_PATH \"\${FILE}\")

    # Construct the full destination path for the file
    set(DEST_FILE \"\${DEST_DIR}/\${REL_PATH}\")

    # Get the directory part of the destination file path
    get_filename_component(DEST_FILE_DIR \"\${DEST_FILE}\" DIRECTORY)

    # Ensure the destination directory exists, then copy the file
    execute_process(COMMAND \"${CMAKE_COMMAND}\" \"-E\" \"make_directory\" \"\${DEST_FILE_DIR}\")
    execute_process(COMMAND \"${CMAKE_COMMAND}\" \"-E\" \"copy_if_different\" \"\${FILE}\" \"\${DEST_FILE}\")
endforeach()

# Create marker directory
execute_process(COMMAND \"${CMAKE_COMMAND}\" \"-E\" \"make_directory\" \"${CMAKE_CURRENT_BINARY_DIR}/.staging_markers\")
# Touch the marker file to indicate completion
execute_process(COMMAND \"${CMAKE_COMMAND}\" \"-E\" \"touch\" \"${STAGING_MARKER_FILE}\")

# --- End of generated script ---
")

    # Use file(GENERATE) to create the script file at build-system generation time.
    file(GENERATE OUTPUT ${SCRIPT_PATH} CONTENT "${SCRIPT_CONTENT}")

    if(ARG_EXTERNAL_PROJECT_DEPENDENCY)
        add_dependencies(${ARG_ATTACH_TO} ${ARG_EXTERNAL_PROJECT_DEPENDENCY})
    endif()

    add_custom_command(
      TARGET ${ARG_ATTACH_TO}
      POST_BUILD
      COMMAND ${CMAKE_COMMAND} -P ${SCRIPT_PATH}
      COMMENT "Staging headers from ${DIR} to ${DEST_DIR}"
      VERBATIM)
  endforeach()

  # Stage headers associated with targets
  foreach(TGT IN LISTS ARG_TARGETS)
    if(TARGET ${TGT})
      # Unique names for script and marker
      string(MAKE_C_IDENTIFIER "stage_headers_tgt_${TGT}_marker" _marker_name)
      set(STAGING_MARKER_FILE "${CMAKE_CURRENT_BINARY_DIR}/.staging_markers/${_marker_name}")
      set(SCRIPT_PATH "${CMAKE_CURRENT_BINARY_DIR}/stage_headers_scripts/stage_tgt_${TGT}_headers.cmake")

      # Content of the script
      file(GENERATE
        OUTPUT ${SCRIPT_PATH}
        CONTENT "
          set(DIRS \"$<TARGET_PROPERTY:${TGT},INTERFACE_INCLUDE_DIRECTORIES>\")
          set(DEST_DIR \"${DEST_DIR}\") # Pass DEST_DIR from parent scope
          execute_process(COMMAND \"${CMAKE_COMMAND}\" \"-E\" \"make_directory\" \"\${DEST_DIR}\")

          foreach(DIR IN LISTS DIRS)
            if(EXISTS \"\${DIR}\")
              file(GLOB_RECURSE ALL_FILES LIST_DIRECTORIES false FOLLOW_SYMLINKS \"\${DIR}/*\")
              foreach(FILE \${ALL_FILES})
                # Check if it's a header file
                get_filename_extension(FILE_EXT \"\${FILE}\")
                if(FILE_EXT STREQUAL \".h\" OR FILE_EXT STREQUAL \".hpp\")
                  string(REPLACE \"\${DIR}/\" \"\" REL_PATH \"\${FILE}\")
                  set(DEST_FILE \"\${DEST_DIR}/\${REL_PATH}\")
                  get_filename_component(DEST_FILE_DIR \"\${DEST_FILE}\" DIRECTORY)
                  execute_process(COMMAND \"${CMAKE_COMMAND}\" \"-E\" \"make_directory\" \"\${DEST_FILE_DIR}\")
                  execute_process(COMMAND \"${CMAKE_COMMAND}\" \"-E\" \"copy_if_different\" \"\${FILE}\" \"\${DEST_FILE}\")
                endif()
              endforeach()
            endif()
          endforeach()

          # Create marker directory
          execute_process(COMMAND \"${CMAKE_COMMAND}\" \"-E\" \"make_directory\" \"${CMAKE_CURRENT_BINARY_DIR}/.staging_markers\")
          # Touch the marker file to indicate completion
          execute_process(COMMAND \"${CMAKE_COMMAND}\" \"-E\" \"touch\" \"${STAGING_MARKER_FILE}\")
        "
      )

      add_dependencies(${ARG_ATTACH_TO} ${TGT})
      add_custom_command(
        TARGET ${ARG_ATTACH_TO}
        POST_BUILD
        COMMAND ${CMAKE_COMMAND} -P ${SCRIPT_PATH}
        COMMENT "Staging headers for target ${TGT} to ${DEST_DIR}"
        VERBATIM)
    endif()
  endforeach()
endfunction()

# --- pylabhub_stage_executable ---
#
# Schedules the copying of an executable target to the staging area.
# This is a simple wrapper around `add_custom_command` that ensures a
# consistent pattern for staging executables.
#
# Usage:
#   pylabhub_stage_executable(
#     TARGET <target_name>          # The executable target to stage.
#     DESTINATION <subdir>          # The subdirectory within `${PYLABHUB_STAGING_DIR}` (e.g., 'bin').
#     ATTACH_TO <target_name>       # The custom target to attach the copy command to.
#   )
#
function(pylabhub_stage_executable)
  set(options "")
  set(oneValueArgs "TARGET;DESTINATION;ATTACH_TO")
  set(multiValueArgs "")
  cmake_parse_arguments(ARG "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})

  if(NOT ARG_TARGET OR NOT ARG_DESTINATION OR NOT ARG_ATTACH_TO)
    message(FATAL_ERROR "pylabhub_stage_executable requires TARGET, DESTINATION, and ATTACH_TO arguments.")
  endif()
  if(NOT TARGET ${ARG_TARGET})
    message(FATAL_ERROR "pylabhub_stage_executable: Target '${ARG_TARGET}' does not exist.")
  endif()

  set(DEST_DIR "${PYLABHUB_STAGING_DIR}/${ARG_DESTINATION}")
  set(SOURCE_FILE "$<TARGET_FILE:${ARG_TARGET}>")
  
# Create a unique marker file that indicates this specific staging operation has completed.
string(MAKE_C_IDENTIFIER "stage_exe_${ARG_TARGET}_${ARG_DESTINATION}_marker" _marker_name)
set(STAGING_MARKER_FILE "${CMAKE_CURRENT_BINARY_DIR}/.staging_markers/${_marker_name}")

# Ensure we list the files we depend on
set(DEPENDENCY_FILES "${SOURCE_FILE}" create_staging_dirs) # Always depend on create_staging_dirs
if(MSVC)
  set(SOURCE_PDB "$<TARGET_PDB_FILE:${ARG_TARGET}>")
  list(APPEND DEPENDENCY_FILES "${SOURCE_PDB}")
endif()

# Build the custom command with separate COMMAND lines so each ${CMAKE_COMMAND} invocation runs alone.
add_custom_command(
  OUTPUT "${STAGING_MARKER_FILE}"
  DEPENDS ${DEPENDENCY_FILES}
  COMMENT "Staging executable and symbols for ${ARG_TARGET} to ${DEST_DIR}"
  VERBATIM

  # create the marker directory
  COMMAND ${CMAKE_COMMAND} -E make_directory "$<TARGET_FILE_DIR:${ARG_TARGET}>/.dummy"  # harmless ensure-parents
  # ensure the staging mark dir exists
  COMMAND ${CMAKE_COMMAND} -E make_directory "${CMAKE_CURRENT_BINARY_DIR}/.staging_markers"
  # ensure destination dir exists
  COMMAND ${CMAKE_COMMAND} -E make_directory "${DEST_DIR}"
  # copy the exe (use generator expression if SOURCE_FILE is target file)
  COMMAND ${CMAKE_COMMAND} -E copy_if_different "${SOURCE_FILE}" "${DEST_DIR}/"
)

if(MSVC)
  # add the PDB copy as additional custom command step by attaching to same OUTPUT
  add_custom_command(
    OUTPUT "${STAGING_MARKER_FILE}"  # same marker file: CMake will consider the commands together
    DEPENDS "${SOURCE_PDB}"
    VERBATIM
    COMMAND ${CMAKE_COMMAND} -E copy_if_different "${SOURCE_PDB}" "${DEST_DIR}/"
    APPEND
  )
endif()

# finally touch the marker in a separate add_custom_command so it runs after the copies
add_custom_command(
  OUTPUT "${STAGING_MARKER_FILE}"
  COMMAND ${CMAKE_COMMAND} -E touch "${STAGING_MARKER_FILE}"
  APPEND
)

# Create a custom target that depends on the marker file.
string(MAKE_C_IDENTIFIER "pylabhub_stage_target_exe_${ARG_TARGET}_${ARG_DESTINATION}" _unique_stage_target_name)
add_custom_target(${_unique_stage_target_name} DEPENDS "${STAGING_MARKER_FILE}")

# Make the ATTACH_TO target depend on this unique custom target.
add_dependencies(${ARG_ATTACH_TO} ${_unique_stage_target_name})

endfunction()


# --- pylabhub_get_library_staging_commands ---
#
# Generates a list of CMake COMMANDs needed to stage a project library.
# This function does not execute the commands itself; it returns them in an
# output variable, making it suitable for use with `add_custom_target`.
#
# It correctly handles platform-specific library types:
#   - Runtime artifacts (.dll, .so, .dylib) are staged to the `DESTINATION` subdir.
#   - Link-time artifacts (.lib, .a) are always staged to the `lib/` subdir.
#
# Usage:
#   pylabhub_get_library_staging_commands(
#     TARGET <target_name>          # The library target to stage.
#     DESTINATION <subdir>          # The subdirectory within `${PYLABHUB_STAGING_DIR}` for RUNTIME artifacts (e.g., 'bin').
#     OUT_COMMANDS <var_name>       # The variable to store the generated list of commands in.
#   )
#
function(pylabhub_get_library_staging_commands)
  cmake_parse_arguments(ARG "" "TARGET;DESTINATION;OUT_COMMANDS;ABSOLUTE_DIR" "" ${ARGN})

  if(NOT ARG_TARGET OR NOT ARG_DESTINATION OR NOT ARG_OUT_COMMANDS)
    message(FATAL_ERROR "pylabhub_get_library_staging_commands requires TARGET, "
                        "DESTINATION, and OUT_COMMANDS arguments.")
  endif()

  if(NOT TARGET ${ARG_TARGET})
    message(FATAL_ERROR "pylabhub_get_library_staging_commands: Target '${ARG_TARGET}' does not exist.")
  endif()

  if(${ARG_ABSOLUTE_DIR})
    set(RUNTIME_DEST_DIR "${ARG_DESTINATION}")
    set(LINKTIME_DEST_DIR "${ARG_DESTINATION}")
  else()
    set(RUNTIME_DEST_DIR "${PYLABHUB_STAGING_DIR}/${ARG_DESTINATION}")
    set(LINKTIME_DEST_DIR "${PYLABHUB_STAGING_DIR}/lib")
  endif()
  
  message(STATUS "** DEBUG: pylabhub_get_library_staging_commands called for target ${ARG_TARGET}")
  message(STATUS "** DEBUG: RUNETIME_DEST_DIR set as: ${RUNTIME_DEST_DIR}")
  message(STATUS "** DEBUG: LINKTIME_DEST_DIR set as: ${LINKTIME_DEST_DIR}")
  get_target_property(TGT_TYPE ${ARG_TARGET} TYPE)

  set(commands_list "")

  if(TGT_TYPE STREQUAL "SHARED_LIBRARY" OR TGT_TYPE STREQUAL "MODULE_LIBRARY")
    if(PYLABHUB_IS_WINDOWS)
      # On Windows, a shared library has a runtime part (.dll) and an import library part (.lib).
      # Stage the runtime to the destination (e.g., 'bin') and the link-time lib to 'lib'.
      message(STATUS "  ** pylabhub staging Target: ${ARG_TARGET}: runtime staging dir: ${RUNTIME_DEST_DIR}")
      list(APPEND commands_list COMMAND ${CMAKE_COMMAND} -E copy_if_different
           "$<TARGET_FILE:${ARG_TARGET}>" "${RUNTIME_DEST_DIR}/")
      if(MSVC)
        list(APPEND commands_list COMMAND ${CMAKE_COMMAND} -E copy_if_different
              "$<TARGET_PDB_FILE:${ARG_TARGET}>" "${RUNTIME_DEST_DIR}/")
      endif()
      # Only Shared Libraries have import libs (.lib); Module Libraries (plugins) generally do not.
      if(TGT_TYPE STREQUAL "SHARED_LIBRARY")
        message(STATUS "  ** pylabhub staging Target: ${ARG_TARGET}: link-time staging dir: ${LINKTIME_DEST_DIR}")
        list(APPEND commands_list COMMAND ${CMAKE_COMMAND} -E copy_if_different
        "$<TARGET_LINKER_FILE:${ARG_TARGET}>" "${LINKTIME_DEST_DIR}/")
      endif()
    else() # Non-Windows platforms (Linux, macOS)
      # On non-Windows platforms (Linux, macOS), the shared library file is used for both
      # runtime and linking. Stage it to the specified destination.
      message(STATUS "  ** pylabhub staging Target: ${ARG_TARGET}: runtime staging dir: ${RUNTIME_DEST_DIR}")

      list(APPEND commands_list COMMAND ${CMAKE_COMMAND} -E copy_if_different
           "$<TARGET_FILE:${ARG_TARGET}>" "${RUNTIME_DEST_DIR}/")
      
      # On Linux and macOS, also place a copy/symlink in the 'lib' directory
      # if the runtime destination is not already 'lib'. This ensures the library
      # is discoverable for linking and also at runtime if needed via default search paths.
      if(PYLABHUB_IS_POSIX) # <--- Correctly handle macOS here
        if(NOT "${RUNTIME_DEST_DIR}" STREQUAL "${LINKTIME_DEST_DIR}")
          message(STATUS "  ** pylabhub staging Target: ${ARG_TARGET}: link-time staging dir: ${LINKTIME_DEST_DIR}")
          list(APPEND commands_list COMMAND ${CMAKE_COMMAND} -E copy_if_different
               "$<TARGET_FILE:${ARG_TARGET}>" "${LINKTIME_DEST_DIR}/")
        endif()
      endif()
    endif()
  elseif(TGT_TYPE STREQUAL "STATIC_LIBRARY")
    # Static libraries are link-time only. Stage the archive (.a, .lib) to the link-time directory.
    message(STATUS "  ** pylabhub staging Target: ${ARG_TARGET}: static lib staging dir: ${LINKTIME_DEST_DIR}")
    list(APPEND commands_list COMMAND ${CMAKE_COMMAND} -E copy_if_different
         "$<TARGET_FILE:${ARG_TARGET}>" "${LINKTIME_DEST_DIR}/")
  endif()

  set(${ARG_OUT_COMMANDS} ${commands_list} PARENT_SCOPE)
endfunction()

# --- pylabhub_stage_libraries ---
#
# A convenience wrapper for staging third-party libraries.
#
# This function attaches staging commands for the given library targets directly
# to the `stage_third_party_deps` custom target. It uses the more general
# `pylabhub_get_library_staging_commands` function internally to generate the
# correct, platform-aware copy commands.
#
# Usage:
#   pylabhub_stage_libraries(TARGETS <target1> <target2> ...)
#   pylabhub_stage_libraries(
#     TARGETS <target1> ...         # The library targets to stage.
#     [ATTACH_TO <target_name>]     # The custom target to attach commands to. (Default: stage_third_party_deps)
#   )
#
function(pylabhub_stage_libraries)
  set(options "")
  set(oneValueArgs "ATTACH_TO")
  set(multiValueArgs "TARGETS")
  cmake_parse_arguments(ARG "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})

  if(NOT ARG_ATTACH_TO)
    set(ARG_ATTACH_TO "stage_third_party_deps")
  endif()

  foreach(TGT IN LISTS ARG_TARGETS)
    if(TARGET ${TGT})
      # Generate the appropriate staging commands for this library target.
      # Runtime components will be directed to 'bin/'.
      # Link-time components will be directed to 'lib/'.
      pylabhub_get_library_staging_commands(
        TARGET ${TGT}
        DESTINATION bin
        OUT_COMMANDS stage_commands_list
      )

      # Collect DEPENDS for the custom command
      set(DEPENDENCY_FILES ${TGT} create_staging_dirs)
      
      # Get target properties
      get_target_property(TGT_TYPE ${TGT} TYPE)
      get_target_property(IS_IMPORTED ${TGT} IMPORTED)

      # Only add target_file for types that have them
      if(TGT_TYPE STREQUAL "SHARED_LIBRARY" OR TGT_TYPE STREQUAL "MODULE_LIBRARY" OR TGT_TYPE STREQUAL "STATIC_LIBRARY" OR TGT_TYPE STREQUAL "EXECUTABLE")
        list(APPEND DEPENDENCY_FILES "$<TARGET_FILE:${TGT}>")
      endif()

      # Add PDB and Linker File only for MSVC and appropriate target types
      if(MSVC)
        if(NOT IS_IMPORTED) # Generator expression TARGET_PDB_FILE not allowed for IMPORTED targets
          if(TGT_TYPE STREQUAL "EXECUTABLE" OR TGT_TYPE STREQUAL "SHARED_LIBRARY" OR TGT_TYPE STREQUAL "MODULE_LIBRARY")
            # These are the primary types that produce PDBs directly managed by the current build
            list(APPEND DEPENDENCY_FILES "$<TARGET_PDB_FILE:${TGT}>")
          endif()
        endif()
        # TARGET_LINKER_FILE is only for shared libraries on Windows (the import lib)
        if(TGT_TYPE STREQUAL "SHARED_LIBRARY")
          list(APPEND DEPENDENCY_FILES "$<TARGET_LINKER_FILE:${TGT}>")
        endif()
      endif()

      # Create a unique marker file that indicates this specific staging operation has completed.
      string(MAKE_C_IDENTIFIER "stage_lib_${TGT}_marker" _marker_name)
      set(STAGING_MARKER_FILE "${CMAKE_CURRENT_BINARY_DIR}/.staging_markers/${_marker_name}")

      add_dependencies(${ARG_ATTACH_TO} ${TGT})
      add_custom_command(
        TARGET ${ARG_ATTACH_TO}
        POST_BUILD
        COMMAND ${CMAKE_COMMAND} -E make_directory "${PYLABHUB_STAGING_DIR}/lib" # Ensure lib dir exists
        COMMAND ${CMAKE_COMMAND} -E make_directory "${PYLABHUB_STAGING_DIR}/bin" # Ensure bin dir exists
        COMMAND ${stage_commands_list}
        COMMENT "Staging library artifacts for ${TGT}"
        VERBATIM
      )

    endif()
  endforeach()
endfunction()

# --- pylabhub_register_test_for_staging ---
#
# Registers a test executable for staging. This function sets the executable's
# output directory and appends the target name to a global property. The parent
# CMake scope can then collect all registered test targets and add them as
# dependencies to the main 'stage_tests' target.
#
# This pattern avoids directory scope issues with add_custom_command.
#
# Usage:
#   pylabhub_register_test_for_staging(TARGET <target_name>)
#
function(pylabhub_register_test_for_staging)
  set(options "")
  set(oneValueArgs "TARGET")
  set(multiValueArgs "")
  cmake_parse_arguments(ARG "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})

  if(NOT ARG_TARGET)
    message(FATAL_ERROR "pylabhub_register_test_for_staging requires a TARGET argument.")
  endif()

  if(NOT TARGET ${ARG_TARGET})
    message(FATAL_ERROR "pylabhub_register_test_for_staging: Target '${ARG_TARGET}' does not exist.")
  endif()

  # Set the output directory for the executable to be inside the staged 'tests' folder.
  # For single-config generators (e.g., Makefiles, Ninja), setting the base
  # RUNTIME_OUTPUT_DIRECTORY is sufficient. For multi-config generators (e.g.,
  # Visual Studio, Xcode), CMake appends a per-configuration subdirectory by
  # default. To override this and ensure a consistent path, we explicitly set the
  # output directory for each configuration.
  if(CMAKE_CONFIGURATION_TYPES)
    # This is a multi-config generator.
    set(output_dir_props "")
    foreach(config ${CMAKE_CONFIGURATION_TYPES})
      string(TOUPPER ${config} config_upper)
      list(APPEND output_dir_props RUNTIME_OUTPUT_DIRECTORY_${config_upper} "${PYLABHUB_STAGING_DIR}/tests")
    endforeach()
    set_target_properties(${ARG_TARGET} PROPERTIES ${output_dir_props})
  else()
    # This is a single-config generator.
    set_target_properties(${ARG_TARGET} PROPERTIES
      RUNTIME_OUTPUT_DIRECTORY "${PYLABHUB_STAGING_DIR}/tests"
    )
  endif()

  # Register this target to a global property so the parent scope can collect it
  set_property(GLOBAL APPEND PROPERTY PYLABHUB_TEST_EXECUTABLES_TO_STAGE ${ARG_TARGET})
endfunction()

