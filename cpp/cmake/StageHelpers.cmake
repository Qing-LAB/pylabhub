# --------------------------------------------------------------------------- 
# cmake/StageHelpers.cmake
#
# Purpose: Provides a consistent API for staging project artifacts.
#
# This module defines a set of functions that abstract the process of copying
# build artifacts (headers, libraries, executables) into the unified staging
# directory (`${PYLABHUB_STAGING_DIR}`). This ensures that all components of
# the project follow the same conventions for creating a runnable, testable
# layout.
#
# This script provides the following functions:
#
# - pylabhub_stage_headers(...)
#   Schedules third-party header files or directories to be copied to the
#   staging area's `include/` directory.
#
# - pylabhub_stage_executable(...)
#   Sets the output directory for an executable to stage it directly.
#
# - pylabhub_get_library_staging_commands(...)
#   Generates a list of commands to stage a library's files. It correctly
#   handles platform differences and is used by the centralized staging logic.
#
# - pylabhub_register_library_for_staging(...)
#   Registers a library target to a global property, marking it for staging.
#   The actual staging commands are generated later by a centralized process.
#
# - pylabhub_register_test_for_staging(...)
#   Registers a test executable for staging and inclusion in the test aggregator target.
#
# These functions rely on variables like PYLABHUB_STAGING_DIR and custom targets
# like stage_third_party_deps being defined in the top-level CMakeLists.txt.
# --------------------------------------------------------------------------- 
#
cmake_minimum_required(VERSION 3.29)

# --- pylabhub_stage_headers ---
#
# Schedules the copying of header files or directories to the staging area.
# This function is specifically designed for staging third-party headers by
# attaching copy commands to the `stage_third_party_deps` target.
#
# Usage:
#   pylabhub_stage_headers(
#     [TARGETS <target1> ...]       # Stage headers from the INTERFACE_INCLUDE_DIRECTORIES of these targets.
#     [DIRECTORIES <dir1> ...]      # Stage headers from these explicit directories.
#     SUBDIR <subdir_name>          # The subdirectory within `${PYLABHUB_STAGING_DIR}/include` to copy to. (Required)
#     [ATTACH_TO <target_name>]     # The custom target to attach commands to. (Default: stage_third_party_deps)
#   )
#
# Design Notes:
#   This function is primarily for third-party headers, hence the default ATTACH_TO target.
#
#   Staging headers from a target's `INTERFACE_INCLUDE_DIRECTORIES` is complex
#   because the property can contain a generator expression that expands to a
#   list of paths at build time. To handle this robustly, this function uses
#   `file(GENERATE)` to create a small CMake script. This script is executed at
#   build time (via `add_custom_command`), where it can correctly resolve the
#   generator expression, iterate over the resulting list of directories, and
#   copy each one.
#
function(pylabhub_stage_headers)
  set(options "")
  set(oneValueArgs "SUBDIR;ATTACH_TO;EXTERNAL_PROJECT_DEPENDENCY")
  set(multiValueArgs "TARGETS;DIRECTORIES")
  cmake_parse_arguments(ARG "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})

  if(NOT ARG_ATTACH_TO)
    set(ARG_ATTACH_TO "stage_third_party_deps")
  endif()

  if(NOT ARG_SUBDIR)
    message(STATUS " ** pylabhub_stage_headers prepare staging to ${PYLABHUB_STAGING_DIR}/include")
    set(DEST_DIR "${PYLABHUB_STAGING_DIR}/include")
  else()
    message(STATUS " ** pylabhub_stage_headers prepare staging to ${PYLABHUB_STAGING_DIR}/include/${ARG_SUBDIR}")
    set(DEST_DIR "${PYLABHUB_STAGING_DIR}/include/${ARG_SUBDIR}")
  endif()

  # Stage headers from explicit directories
  foreach(DIR IN LISTS ARG_DIRECTORIES)
    # Create a unique name for the script and marker file
    string(RANDOM LENGTH 8 SCRIPT_ID)
    set(SCRIPT_PATH "${CMAKE_CURRENT_BINARY_DIR}/stage_headers_scripts/stage_dir_${SCRIPT_ID}.cmake")

    string(MAKE_C_IDENTIFIER "stage_headers_dir_${SCRIPT_ID}_marker" _marker_name)
    set(STAGING_MARKER_FILE "${CMAKE_CURRENT_BINARY_DIR}/.staging_markers/${_marker_name}")

    # Content of the build-time script
    set(SCRIPT_CONTENT "
# --- This script is generated by pylabhub_stage_headers ---
set(SOURCE_DIR \"${DIR}\")
set(DEST_DIR \"${DEST_DIR}\")
message(STATUS \"[pylabhub_stage_headers customed script] checking source directory \${SOURCE_DIR}.....\")
if(NOT EXISTS \"\${SOURCE_DIR}\")
    message(SEND_ERROR \"Source directory '\${SOURCE_DIR}' for staging does not exist.\")
    return()
endif()

# Find header files recursively within the source directory
file(GLOB_RECURSE ALL_FILES
    LIST_DIRECTORIES false
    FOLLOW_SYMLINKS
    \"\${SOURCE_DIR}/*.h\"
    \"\${SOURCE_DIR}/*.hpp\"
)

# Ensure destination directory exists at execution time
execute_process(COMMAND \"${CMAKE_COMMAND}\" \"-E\" \"make_directory\" \"\${DEST_DIR}\")

foreach(FILE \${ALL_FILES})
    # Get the path of the file relative to the source directory
    string(REPLACE \"\${SOURCE_DIR}/\" \"\" REL_PATH \"\${FILE}\")

    # Construct the full destination path for the file
    set(DEST_FILE \"\${DEST_DIR}/\${REL_PATH}\")

    # Get the directory part of the destination file path
    get_filename_component(DEST_FILE_DIR \"\${DEST_FILE}\" DIRECTORY)

    # Ensure the destination directory exists, then copy the file
    execute_process(COMMAND \"${CMAKE_COMMAND}\" \"-E\" \"make_directory\" \"\${DEST_FILE_DIR}\")
    execute_process(COMMAND \"${CMAKE_COMMAND}\" \"-E\" \"copy_if_different\" \"\${FILE}\" \"\${DEST_FILE}\")
endforeach()

# Create marker directory
execute_process(COMMAND \"${CMAKE_COMMAND}\" \"-E\" \"make_directory\" \"${CMAKE_CURRENT_BINARY_DIR}/.staging_markers\")
# Touch the marker file to indicate completion
execute_process(COMMAND \"${CMAKE_COMMAND}\" \"-E\" \"touch\" \"${STAGING_MARKER_FILE}\")

# --- End of generated script ---
")

    # Use file(GENERATE) to create the script file at build-system generation time.
    file(GENERATE OUTPUT ${SCRIPT_PATH} CONTENT "${SCRIPT_CONTENT}")

    if(ARG_EXTERNAL_PROJECT_DEPENDENCY)
        add_dependencies(${ARG_ATTACH_TO} ${ARG_EXTERNAL_PROJECT_DEPENDENCY})
    endif()

    add_custom_command(
      TARGET ${ARG_ATTACH_TO}
      POST_BUILD
      COMMAND ${CMAKE_COMMAND} -P ${SCRIPT_PATH}
      COMMENT "Staging headers from ${DIR} to ${DEST_DIR}"
      VERBATIM)
  endforeach()

  # Stage headers associated with targets
  foreach(TGT IN LISTS ARG_TARGETS)
    if(TARGET ${TGT})
      # Unique names for script and marker
      string(MAKE_C_IDENTIFIER "stage_headers_tgt_${TGT}_marker" _marker_name)
      set(STAGING_MARKER_FILE "${CMAKE_CURRENT_BINARY_DIR}/.staging_markers/${_marker_name}")
      set(SCRIPT_PATH "${CMAKE_CURRENT_BINARY_DIR}/stage_headers_scripts/stage_tgt_${TGT}_headers.cmake")

      # Content of the script
      file(GENERATE
        OUTPUT ${SCRIPT_PATH}
        CONTENT "
          set(DIRS \"$<TARGET_PROPERTY:${TGT},INTERFACE_INCLUDE_DIRECTORIES>\")
          set(DEST_DIR \"${DEST_DIR}\") # Pass DEST_DIR from parent scope
          execute_process(COMMAND \"${CMAKE_COMMAND}\" \"-E\" \"make_directory\" \"\${DEST_DIR}\")

          foreach(DIR IN LISTS DIRS)
            if(EXISTS \"\${DIR}\")
              file(GLOB_RECURSE ALL_FILES LIST_DIRECTORIES false FOLLOW_SYMLINKS \"\${DIR}/*\")
              foreach(FILE \${ALL_FILES})
                # Check if it's a header file
                get_filename_extension(FILE_EXT \"\${FILE}\")
                if(FILE_EXT STREQUAL \".h\" OR FILE_EXT STREQUAL \".hpp\")
                  string(REPLACE \"\${DIR}/\" \"\" REL_PATH \"\${FILE}\")
                  set(DEST_FILE \"\${DEST_DIR}/\${REL_PATH}\")
                  get_filename_component(DEST_FILE_DIR \"\${DEST_FILE}\" DIRECTORY)
                  execute_process(COMMAND \"${CMAKE_COMMAND}\" \"-E\" \"make_directory\" \"\${DEST_FILE_DIR}\")
                  execute_process(COMMAND \"${CMAKE_COMMAND}\" \"-E\" \"copy_if_different\" \"\${FILE}\" \"\${DEST_FILE}\")
                endif()
              endforeach()
            endif()
          endforeach()

          # Create marker directory
          execute_process(COMMAND \"${CMAKE_COMMAND}\" \"-E\" \"make_directory\" \"${CMAKE_CURRENT_BINARY_DIR}/.staging_markers\")
          # Touch the marker file to indicate completion
          execute_process(COMMAND \"${CMAKE_COMMAND}\" \"-E\" \"touch\" \"${STAGING_MARKER_FILE}\")
        "
      )

      add_dependencies(${ARG_ATTACH_TO} ${TGT})
      add_custom_command(
        TARGET ${ARG_ATTACH_TO}
        POST_BUILD
        COMMAND ${CMAKE_COMMAND} -P ${SCRIPT_PATH}
        COMMENT "Staging headers for target ${TGT} to ${DEST_DIR}"
        VERBATIM)
    endif()
  endforeach()
endfunction()

# --- pylabhub_stage_executable ---
#
# Sets the output directory for an executable target to place it directly
# into the staging area. This is the preferred modern CMake approach.
#
# Usage:
#   pylabhub_stage_executable(
#     TARGET <target_name>          # The executable target to stage.
#     DESTINATION <subdir>          # The subdirectory within `${PYLABHUB_STAGING_DIR}` (e.g., 'bin').
#   )
#
function(pylabhub_stage_executable)
  set(options "")
  set(oneValueArgs "TARGET;DESTINATION")
  set(multiValueArgs "")
  cmake_parse_arguments(ARG "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})

  if(NOT ARG_TARGET OR NOT ARG_DESTINATION)
    message(FATAL_ERROR "pylabhub_stage_executable requires TARGET and DESTINATION arguments.")
  endif()
  if(NOT TARGET ${ARG_TARGET})
    message(FATAL_ERROR "pylabhub_stage_executable: Target '${ARG_TARGET}' does not exist.")
  endif()

  set(STAGED_DEST_DIR "${PYLABHUB_STAGING_DIR}/${ARG_DESTINATION}")

  # For multi-config generators (e.g., Visual Studio, Xcode), we must set the
  # output directory property for each configuration type. For single-config
  # generators, setting the base property is sufficient.
  if(CMAKE_CONFIGURATION_TYPES)
    set(output_dir_props "")
    foreach(config ${CMAKE_CONFIGURATION_TYPES})
      string(TOUPPER ${config} config_upper)
      list(APPEND output_dir_props RUNTIME_OUTPUT_DIRECTORY_${config_upper} "${STAGED_DEST_DIR}")
      if(MSVC)
        list(APPEND output_dir_props PDB_OUTPUT_DIRECTORY_${config_upper} "${STAGED_DEST_DIR}")
      endif()
    endforeach()
    set_target_properties(${ARG_TARGET} PROPERTIES ${output_dir_props})
  else()
    set_target_properties(${ARG_TARGET} PROPERTIES
      RUNTIME_OUTPUT_DIRECTORY "${STAGED_DEST_DIR}"
    )
    if(MSVC)
       set_target_properties(${ARG_TARGET} PROPERTIES
        PDB_OUTPUT_DIRECTORY "${STAGED_DEST_DIR}"
      )
    endif()
  endif()

endfunction()


# --- pylabhub_get_library_staging_commands ---
#
# Generates a list of CMake COMMANDs needed to stage a project library.
# This function does not execute the commands itself; it returns them in an
# output variable, making it suitable for use with `add_custom_target`.
#
# It correctly handles platform-specific library types:
#   - Runtime artifacts (.dll, .so, .dylib) are staged to the `DESTINATION` subdir.
#   - Link-time artifacts (.lib, .a) are always staged to the `lib/` subdir.
#
# Usage:
#   pylabhub_get_library_staging_commands(
#     TARGET <target_name>          # The library target to stage.
#     DESTINATION <subdir>          # The subdirectory within `${PYLABHUB_STAGING_DIR}` for RUNTIME artifacts (e.g., 'bin').
#     OUT_COMMANDS <var_name>       # The variable to store the generated list of commands in.
#   )
#
function(pylabhub_get_library_staging_commands)
  cmake_parse_arguments(ARG "" "TARGET;DESTINATION;OUT_COMMANDS;ABSOLUTE_DIR" "" ${ARGN})

  if(NOT ARG_TARGET OR NOT ARG_DESTINATION OR NOT ARG_OUT_COMMANDS)
    message(FATAL_ERROR "pylabhub_get_library_staging_commands requires TARGET, "
                        "DESTINATION, and OUT_COMMANDS arguments.")
  endif()

  if(NOT TARGET ${ARG_TARGET})
    message(FATAL_ERROR "pylabhub_get_library_staging_commands: Target '${ARG_TARGET}' does not exist.")
  endif()

  if(${ARG_ABSOLUTE_DIR})
    set(RUNTIME_DEST_DIR "${ARG_DESTINATION}")
    set(LINKTIME_DEST_DIR "${ARG_DESTINATION}")
  else()
    set(RUNTIME_DEST_DIR "${PYLABHUB_STAGING_DIR}/${ARG_DESTINATION}")
    set(LINKTIME_DEST_DIR "${PYLABHUB_STAGING_DIR}/lib")
  endif()
  
  message(STATUS "** DEBUG: pylabhub_get_library_staging_commands called for target ${ARG_TARGET}")
  message(STATUS "** DEBUG: RUNETIME_DEST_DIR set as: ${RUNTIME_DEST_DIR}")
  message(STATUS "** DEBUG: LINKTIME_DEST_DIR set as: ${LINKTIME_DEST_DIR}")
  get_target_property(TGT_TYPE ${ARG_TARGET} TYPE)

  set(commands_list "")

  if(TGT_TYPE STREQUAL "SHARED_LIBRARY" OR TGT_TYPE STREQUAL "MODULE_LIBRARY")
    if(PYLABHUB_IS_WINDOWS)
      # On Windows, a shared library has a runtime part (.dll) and an import library part (.lib).
      # Stage the runtime to the destination (e.g., 'bin') and the link-time lib to 'lib'.
      message(STATUS "  ** pylabhub staging Target: ${ARG_TARGET}: runtime staging dir: ${RUNTIME_DEST_DIR}")
      list(APPEND commands_list COMMAND ${CMAKE_COMMAND} -E copy_if_different
           "$<TARGET_FILE:${ARG_TARGET}>" "${RUNTIME_DEST_DIR}/")
      if(MSVC)
        list(APPEND commands_list COMMAND ${CMAKE_COMMAND} -E copy_if_different
              "$<TARGET_PDB_FILE:${ARG_TARGET}>" "${RUNTIME_DEST_DIR}/")
      endif()
      # Only Shared Libraries have import libs (.lib); Module Libraries (plugins) generally do not.
      if(TGT_TYPE STREQUAL "SHARED_LIBRARY")
        message(STATUS "  ** pylabhub staging Target: ${ARG_TARGET}: link-time staging dir: ${LINKTIME_DEST_DIR}")
        list(APPEND commands_list COMMAND ${CMAKE_COMMAND} -E copy_if_different
        "$<TARGET_LINKER_FILE:${ARG_TARGET}>" "${LINKTIME_DEST_DIR}/")
      endif()
    else() # Non-Windows platforms (Linux, macOS)
      # On non-Windows platforms (Linux, macOS), the shared library file is used for both
      # runtime and linking. Stage it to the specified destination.
      message(STATUS "  ** pylabhub staging Target: ${ARG_TARGET}: runtime staging dir: ${RUNTIME_DEST_DIR}")

      list(APPEND commands_list COMMAND ${CMAKE_COMMAND} -E copy_if_different
           "$<TARGET_FILE:${ARG_TARGET}>" "${RUNTIME_DEST_DIR}/")
      
      # On Linux and macOS, also place a copy/symlink in the 'lib' directory
      # if the runtime destination is not already 'lib'. This ensures the library
      # is discoverable for linking and also at runtime if needed via default search paths.
      if(PYLABHUB_IS_POSIX) # Handle POSIX systems (Linux and macOS)
        if(NOT "${RUNTIME_DEST_DIR}" STREQUAL "${LINKTIME_DEST_DIR}")
          message(STATUS "  ** pylabhub staging Target: ${ARG_TARGET}: link-time staging dir: ${LINKTIME_DEST_DIR}")
          list(APPEND commands_list COMMAND ${CMAKE_COMMAND} -E copy_if_different
               "$<TARGET_FILE:${ARG_TARGET}>" "${LINKTIME_DEST_DIR}/")
        endif()
      endif()
    endif()
  elseif(TGT_TYPE STREQUAL "STATIC_LIBRARY")
    # Static libraries are link-time only. Stage the archive (.a, .lib) to the link-time directory.
    message(STATUS "  ** pylabhub staging Target: ${ARG_TARGET}: static lib staging dir: ${LINKTIME_DEST_DIR}")
    list(APPEND commands_list COMMAND ${CMAKE_COMMAND} -E copy_if_different
         "$<TARGET_FILE:${ARG_TARGET}>" "${LINKTIME_DEST_DIR}/")
  endif()

  set(${ARG_OUT_COMMANDS} ${commands_list} PARENT_SCOPE)
endfunction()

# --- pylabhub_register_library_for_staging ---
#
# Registers a library target to be staged.
#
# This function simply appends the target name to a global property. A separate,
# centralized process will collect all targets from this property and generate
# the necessary staging commands. This decouples the declaration from the
# implementation.
#
# Usage:
#   pylabhub_register_library_for_staging(TARGET <target_name>)
#
function(pylabhub_register_library_for_staging)
  set(options "")
  set(oneValueArgs "TARGET")
  set(multiValueArgs "")
  cmake_parse_arguments(ARG "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})

  if(NOT ARG_TARGET)
    message(FATAL_ERROR "pylabhub_register_library_for_staging requires a TARGET argument.")
  endif()

  if(NOT TARGET ${ARG_TARGET})
    message(FATAL_ERROR "pylabhub_register_library_for_staging: Target '${ARG_TARGET}' does not exist.")
  endif()
  
  set_property(GLOBAL APPEND PROPERTY PYLABHUB_LIBRARIES_TO_STAGE ${ARG_TARGET})
endfunction()


# --- pylabhub_register_test_for_staging ---
#
# Registers a test executable for staging. This function sets the executable's
# output directory and appends the target name to a global property. The parent
# CMake scope can then collect all registered test targets and add them as
# dependencies to the main 'stage_tests' target.
#
# This pattern avoids directory scope issues with add_custom_command.
#
# Usage:
#   pylabhub_register_test_for_staging(TARGET <target_name>)
#
function(pylabhub_register_test_for_staging)
  set(options "")
  set(oneValueArgs "TARGET")
  set(multiValueArgs "")
  cmake_parse_arguments(ARG "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})

  if(NOT ARG_TARGET)
    message(FATAL_ERROR "pylabhub_register_test_for_staging requires a TARGET argument.")
  endif()

  if(NOT TARGET ${ARG_TARGET})
    message(FATAL_ERROR "pylabhub_register_test_for_staging: Target '${ARG_TARGET}' does not exist.")
  endif()

  # Set the output directory for the executable to be inside the staged 'tests' folder.
  # For single-config generators (e.g., Makefiles, Ninja), setting the base
  # RUNTIME_OUTPUT_DIRECTORY is sufficient. For multi-config generators (e.g.,
  # Visual Studio, Xcode), CMake appends a per-configuration subdirectory by
  # default. To override this and ensure a consistent path, we explicitly set the
  # output directory for each configuration.
  if(CMAKE_CONFIGURATION_TYPES)
    # This is a multi-config generator.
    set(output_dir_props "")
    foreach(config ${CMAKE_CONFIGURATION_TYPES})
      string(TOUPPER ${config} config_upper)
      list(APPEND output_dir_props RUNTIME_OUTPUT_DIRECTORY_${config_upper} "${PYLABHUB_STAGING_DIR}/tests")
    endforeach()
    set_target_properties(${ARG_TARGET} PROPERTIES ${output_dir_props})
  else()
    # This is a single-config generator.
    set_target_properties(${ARG_TARGET} PROPERTIES
      RUNTIME_OUTPUT_DIRECTORY "${PYLABHUB_STAGING_DIR}/tests"
    )
  endif()

  # Register this target to a global property so the parent scope can collect it
  set_property(GLOBAL APPEND PROPERTY PYLABHUB_TEST_EXECUTABLES_TO_STAGE ${ARG_TARGET})
endfunction()