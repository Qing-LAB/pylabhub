# ---------------------------------------------------------------------------
# cmake/StageHelpers.cmake
#
# Purpose: Provides a consistent API for staging project artifacts.
#
# This module defines a set of functions that abstract the process of copying
# build artifacts (headers, libraries, executables) into the unified staging
# directory (`${PYLABHUB_STAGING_DIR}`). This ensures that all components of
# the project follow the same conventions for creating a runnable, testable
# layout.
#
# This script provides the following functions:
#
# - pylabhub_stage_headers(...)
#   Schedules third-party header files or directories to be copied to the
#   staging area's `include/` directory.
#
# - pylabhub_stage_executable(...)
#   Schedules an executable target to be copied to a destination in the
#   staging area.
#
# - pylabhub_get_library_staging_commands(...)
#   Generates a list of commands to stage a library target. It correctly
#   handles platform differences (e.g., DLLs vs. .so) and separates runtime
#   from link-time artifacts. This function is intended for use with our own
#   project's targets via `add_custom_target`.
#
# - pylabhub_stage_libraries(...)
#   A convenience wrapper that schedules third-party library artifacts to be
#   copied to the staging area. It attaches commands directly to the global
#   `stage_third_party_deps` target.
#
# These functions rely on variables being set by the top-level `CMakeLists.txt`:
#
# - PYLABHUB_STAGING_DIR: The root directory for all staged artifacts.
#
# And on custom targets defined in the build system:
#
# - stage_third_party_deps: The global custom target to which staging
#   commands for third-party libraries are attached.
# ---------------------------------------------------------------------------
#
cmake_minimum_required(VERSION 3.29)

# --- pylabhub_stage_headers ---
#
# Schedules the copying of header files or directories to the staging area.
# This function is specifically designed for staging third-party headers by
# attaching copy commands to the `stage_third_party_deps` target.
#
# Usage:
#   pylabhub_stage_headers(
#     [TARGETS <target1> ...]       # Stage headers from the INTERFACE_INCLUDE_DIRECTORIES of these targets.
#     [DIRECTORIES <dir1> ...]      # Stage headers from these explicit directories.
#     SUBDIR <subdir_name>          # The subdirectory within `${PYLABHUB_STAGING_DIR}/include` to copy to. (Required)
#     [ATTACH_TO <target_name>]     # The custom target to attach commands to. (Default: stage_third_party_deps)
#   )
#
# Design Notes:
#   This function is primarily for third-party headers, hence the default ATTACH_TO target.
#
#   Staging headers from a target's `INTERFACE_INCLUDE_DIRECTORIES` is complex
#   because the property can contain a generator expression that expands to a
#   list of paths at build time. To handle this robustly, this function uses
#   `file(GENERATE)` to create a small CMake script. This script is executed at
#   build time (via `add_custom_command`), where it can correctly resolve the
#   generator expression, iterate over the resulting list of directories, and
#   copy each one.
#
function(pylabhub_stage_headers)
  set(options "")
  set(oneValueArgs "SUBDIR;ATTACH_TO")
  set(multiValueArgs "TARGETS;DIRECTORIES")
  cmake_parse_arguments(ARG "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})

  if(NOT ARG_ATTACH_TO)
    set(ARG_ATTACH_TO "stage_third_party_deps")
  endif()

  if(NOT ARG_SUBDIR)
    message(STATUS " ** pylabhub_stage_headers prepare staging to ${PYLABHUB_STAGING_DIR}/include")
    set(DEST_DIR "${PYLABHUB_STAGING_DIR}/include")
  else()
    message(STATUS " ** pylabhub_stage_headers prepare staging to ${PYLABHUB_STAGING_DIR}/include/${ARG_SUBDIR}")
    set(DEST_DIR "${PYLABHUB_STAGING_DIR}/include/${ARG_SUBDIR}")
  endif()

  # Stage headers from explicit directories
  foreach(DIR IN LISTS ARG_DIRECTORIES)
    # To handle complex directory structures (like libsodium's), we can't
    # use a simple `copy_directory`. It can create incorrect nested folders.
    # Instead, we generate a small CMake script that is executed at build time.
    # This script recursively finds all *files* and copies them one by one,
    # preserving the relative directory structure. This is like a robust
    # `copy_directory` that correctly merges directory contents.

    # Create a unique name for the script to avoid collisions.
    string(RANDOM LENGTH 8 SCRIPT_ID)
    set(SCRIPT_PATH "${CMAKE_CURRENT_BINARY_DIR}/stage_headers_scripts/stage_${ARG_ATTACH_TO}_${SCRIPT_ID}.cmake")

    # Content of the build-time script
    set(SCRIPT_CONTENT "
# --- This script is generated by pylabhub_stage_headers ---
set(SOURCE_DIR \"${DIR}\")
set(DEST_DIR \"${DEST_DIR}\")
message(STATUS \"[pylabhub_stage_headers customed script] checking source directory \${SOURCE_DIR}.....\")
if(NOT EXISTS \"\${SOURCE_DIR}\")
    message(SEND_ERROR \"Source directory '\${SOURCE_DIR}' for staging does not exist.\")
    return()
endif()

# Find all files recursively within the source directory
file(GLOB_RECURSE ALL_FILES
    LIST_DIRECTORIES false
    FOLLOW_SYMLINKS
    \"\${SOURCE_DIR}/*.h\"
    \"\${SOURCE_DIR}/*.hpp\"
)

foreach(FILE \${ALL_FILES})
    # Get the path of the file relative to the source directory
    string(REPLACE \"\${SOURCE_DIR}/\" \"\" REL_PATH \"\${FILE}\")

    # Construct the full destination path for the file
    set(DEST_FILE \"\${DEST_DIR}/\${REL_PATH}\")

    # Get the directory part of the destination file path
    get_filename_component(DEST_FILE_DIR \"\${DEST_FILE}\" DIRECTORY)

    # Ensure the destination directory exists, then copy the file
    execute_process(COMMAND ${CMAKE_COMMAND} -E make_directory \"\${DEST_FILE_DIR}\")
    execute_process(COMMAND ${CMAKE_COMMAND} -E copy_if_different \"\${FILE}\" \"\${DEST_FILE}\")
endforeach()
# --- End of generated script ---
")

    # Use file(GENERATE) to create the script file at build-system generation time.
    file(GENERATE OUTPUT ${SCRIPT_PATH} CONTENT "${SCRIPT_CONTENT}")

    # Add a command to execute this script at build time.
    add_custom_command(TARGET ${ARG_ATTACH_TO} POST_BUILD
      COMMAND ${CMAKE_COMMAND} -P ${SCRIPT_PATH}
      COMMENT "Staging headers from ${DIR} to ${DEST_DIR}"
      VERBATIM)
  endforeach()

  # Stage headers associated with targets
  foreach(TGT IN LISTS ARG_TARGETS)
    if(TARGET ${TGT})
      # The INTERFACE_INCLUDE_DIRECTORIES property can be a list. The add_custom_command
      # needs to handle this list, which is expanded at build time via the generator
      # expression. We use file(GENERATE) to create a small helper script that iterates
      # the list and performs the copy for each directory. This is robust against
      # multiple include directories and paths with spaces.
      set(SCRIPT_PATH "${CMAKE_CURRENT_BINARY_DIR}/stage_headers_scripts/stage_${TGT}_headers.cmake")
      file(GENERATE
        OUTPUT ${SCRIPT_PATH}
        CONTENT "
          set(DIRS \"$<TARGET_PROPERTY:${TGT},INTERFACE_INCLUDE_DIRECTORIES>\")
          foreach(DIR IN LISTS DIRS)
            if(EXISTS \"\${DIR}\")
              # We reuse the same file-by-file copy logic here for consistency
              file(GLOB_RECURSE ALL_FILES LIST_DIRECTORIES false FOLLOW_SYMLINKS \"\${DIR}/*\")
              foreach(FILE \${ALL_FILES})
                string(REPLACE \"\${DIR}/\" \"\" REL_PATH \"\${FILE}\")
                set(DEST_FILE \"\${DEST_DIR}/\${REL_PATH}\")
                get_filename_component(DEST_FILE_DIR \"\${DEST_FILE}\" DIRECTORY)
                execute_process(COMMAND ${CMAKE_COMMAND} -E make_directory \"\${DEST_FILE_DIR}\")
                execute_process(COMMAND ${CMAKE_COMMAND} -E copy_if_different \"\${FILE}\" \"\${DEST_FILE}\")
              endforeach()
            endif()
          endforeach()
        "
      )
      add_custom_command(TARGET ${ARG_ATTACH_TO} POST_BUILD
        COMMAND ${CMAKE_COMMAND} -P ${SCRIPT_PATH}
        COMMENT "Staging headers for target ${TGT} to ${DEST_DIR}"
        VERBATIM)
    endif()
  endforeach()
endfunction()

# --- pylabhub_stage_executable ---
#
# Schedules the copying of an executable target to the staging area.
# This is a simple wrapper around `add_custom_command` that ensures a
# consistent pattern for staging executables.
#
# Usage:
#   pylabhub_stage_executable(
#     TARGET <target_name>          # The executable target to stage.
#     DESTINATION <subdir>          # The subdirectory within `${PYLABHUB_STAGING_DIR}` (e.g., 'bin').
#     ATTACH_TO <target_name>       # The custom target to attach the copy command to.
#   )
#
function(pylabhub_stage_executable)
  set(options "")
  set(oneValueArgs "TARGET;DESTINATION;ATTACH_TO")
  set(multiValueArgs "")
  cmake_parse_arguments(ARG "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})

  if(NOT ARG_TARGET OR NOT ARG_DESTINATION OR NOT ARG_ATTACH_TO)
    message(FATAL_ERROR "pylabhub_stage_executable requires TARGET, DESTINATION, and ATTACH_TO arguments.")
  endif()
  if(NOT TARGET ${ARG_TARGET})
    message(FATAL_ERROR "pylabhub_stage_executable: Target '${ARG_TARGET}' does not exist.")
  endif()

  set(DEST_DIR "${PYLABHUB_STAGING_DIR}/${ARG_DESTINATION}")

  set(stage_commands "")
  list(APPEND stage_commands COMMAND ${CMAKE_COMMAND} -E copy_if_different
        "$<TARGET_FILE:${ARG_TARGET}>"
        "${DEST_DIR}/")
  
  if(MSVC)
    list(APPEND stage_commands COMMAND ${CMAKE_COMMAND} -E copy_if_different
          "$<TARGET_PDB_FILE:${ARG_TARGET}>"
          "${DEST_DIR}/")
  endif()

  add_custom_command(TARGET ${ARG_ATTACH_TO} POST_BUILD
    ${stage_commands}
    COMMENT "Staging executable and symbols for ${ARG_TARGET} to ${DEST_DIR}"
    VERBATIM)
endfunction()

# --- pylabhub_get_library_staging_commands ---
#
# Generates a list of CMake COMMANDs needed to stage a project library.
# This function does not execute the commands itself; it returns them in an
# output variable, making it suitable for use with `add_custom_target`.
#
# It correctly handles platform-specific library types:
#   - Runtime artifacts (.dll, .so, .dylib) are staged to the `DESTINATION` subdir.
#   - Link-time artifacts (.lib, .a) are always staged to the `lib/` subdir.
#
# Usage:
#   pylabhub_get_library_staging_commands(
#     TARGET <target_name>          # The library target to stage.
#     DESTINATION <subdir>          # The subdirectory within `${PYLABHUB_STAGING_DIR}` for RUNTIME artifacts (e.g., 'bin').
#     OUT_COMMANDS <var_name>       # The variable to store the generated list of commands in.
#   )
#
function(pylabhub_get_library_staging_commands)
  cmake_parse_arguments(ARG "" "TARGET;DESTINATION;OUT_COMMANDS;ABSOLUTE_DIR" "" ${ARGN})

  if(NOT ARG_TARGET OR NOT ARG_DESTINATION OR NOT ARG_OUT_COMMANDS)
    message(FATAL_ERROR "pylabhub_get_library_staging_commands requires TARGET, "
                        "DESTINATION, and OUT_COMMANDS arguments.")
  endif()

  if(NOT TARGET ${ARG_TARGET})
    message(FATAL_ERROR "pylabhub_get_library_staging_commands: Target '${ARG_TARGET}' does not exist.")
  endif()

  if(${ARG_ABSOLUTE_DIR})
    set(RUNTIME_DEST_DIR "${ARG_DESTINATION}")
    set(LINKTIME_DEST_DIR "${ARG_DESTINATION}")
  else()
    set(RUNTIME_DEST_DIR "${PYLABHUB_STAGING_DIR}/${ARG_DESTINATION}")
    set(LINKTIME_DEST_DIR "${PYLABHUB_STAGING_DIR}/lib")
  endif()
     
  get_target_property(TGT_TYPE ${ARG_TARGET} TYPE)

  set(commands_list "")

  if(TGT_TYPE STREQUAL "SHARED_LIBRARY" OR TGT_TYPE STREQUAL "MODULE_LIBRARY")
    if(PLATFORM_WIN64)
      # On Windows, a shared library has a runtime part (.dll) and an import library part (.lib).
      # Stage the runtime to the destination (e.g., 'bin') and the link-time lib to 'lib'.
      message(STATUS "  ** pylabhub staging Target: ${ARG_TARGET}: runtime staging dir: ${RUNTIME_DEST_DIR}")
      list(APPEND commands_list COMMAND ${CMAKE_COMMAND} -E copy_if_different
           "$<TARGET_FILE:${ARG_TARGET}>" "${RUNTIME_DEST_DIR}/")
      if(MSVC)
        list(APPEND commands_list COMMAND ${CMAKE_COMMAND} -E copy_if_different
              "$<TARGET_PDB_FILE:${ARG_TARGET}>" "${RUNTIME_DEST_DIR}/")
      endif()
      # Only Shared Libraries have import libs (.lib); Module Libraries (plugins) generally do not.
      if(TGT_TYPE STREQUAL "SHARED_LIBRARY")
        message(STATUS "  ** pylabhub staging Target: ${ARG_TARGET}: link-time staging dir: ${LINKTIME_DEST_DIR}")
        list(APPEND commands_list COMMAND ${CMAKE_COMMAND} -E copy_if_different
        "$<TARGET_LINKER_FILE:${ARG_TARGET}>" "${LINKTIME_DEST_DIR}/")
      endif()
    else()
      # On non-Windows platforms (Linux, macOS), the shared library file is used for both
      # runtime and linking. Stage it to the specified destination (e.g., 'bin').
      message(STATUS "  ** pylabhub staging Target: ${ARG_TARGET}: runtime staging dir: ${RUNTIME_DEST_DIR}")      
      list(APPEND commands_list COMMAND ${CMAKE_COMMAND} -E copy_if_different
           "$<TARGET_FILE:${ARG_TARGET}>" "${RUNTIME_DEST_DIR}/")
      # On Linux, also place a copy/symlink in the 'lib' directory for consumers to find during linking.
      if(PLATFORM_LINUX)
        if(NOT "${RUNTIME_DEST_DIR}" STREQUAL "${LINKTIME_DEST_DIR}")
        message(STATUS "  ** pylabhub staging Target: ${ARG_TARGET}: link-time staging dir: ${LINKTIME_DEST_DIR}")
          list(APPEND commands_list COMMAND ${CMAKE_COMMAND} -E copy_if_different
               "$<TARGET_FILE:${ARG_TARGET}>" "${LINKTIME_DEST_DIR}/")
        endif()
      endif()
    endif()
  elseif(TGT_TYPE STREQUAL "STATIC_LIBRARY")
    # Static libraries are link-time only. Stage the archive (.a, .lib) to the link-time directory.
    message(STATUS "  ** pylabhub staging Target: ${ARG_TARGET}: static lib staging dir: ${LINKTIME_DEST_DIR}")
    list(APPEND commands_list COMMAND ${CMAKE_COMMAND} -E copy_if_different
         "$<TARGET_FILE:${ARG_TARGET}>" "${LINKTIME_DEST_DIR}/")
  endif()

  set(${ARG_OUT_COMMANDS} ${commands_list} PARENT_SCOPE)
endfunction()

# --- pylabhub_stage_libraries ---
#
# A convenience wrapper for staging third-party libraries.
#
# This function attaches staging commands for the given library targets directly
# to the `stage_third_party_deps` custom target. It uses the more general
# `pylabhub_get_library_staging_commands` function internally to generate the
# correct, platform-aware copy commands.
#
# Usage:
#   pylabhub_stage_libraries(TARGETS <target1> <target2> ...)
#   pylabhub_stage_libraries(
#     TARGETS <target1> ...         # The library targets to stage.
#     [ATTACH_TO <target_name>]     # The custom target to attach commands to. (Default: stage_third_party_deps)
#   )
#
function(pylabhub_stage_libraries)
  set(options "")
  set(oneValueArgs "ATTACH_TO")
  set(multiValueArgs "TARGETS")
  cmake_parse_arguments(ARG "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})

  if(NOT ARG_ATTACH_TO)
    set(ARG_ATTACH_TO "stage_third_party_deps")
  endif()

  foreach(TGT IN LISTS ARG_TARGETS)
    if(TARGET ${TGT})
      # Generate the appropriate staging commands for this library target.
      # Runtime components will be directed to 'bin/'.
      # Link-time components will be directed to 'lib/'.
      pylabhub_get_library_staging_commands(
        TARGET ${TGT}
        DESTINATION bin
        OUT_COMMANDS stage_commands
      )
      add_custom_command(TARGET ${ARG_ATTACH_TO} POST_BUILD
        ${stage_commands}
        COMMENT "Staging library artifacts for ${TGT}" VERBATIM)
    endif()
  endforeach()
endfunction()

# --- pylabhub_register_test_for_staging ---
#
# Registers a test executable for staging. This function sets the executable's
# output directory and appends the target name to a global property. The parent
# CMake scope can then collect all registered test targets and add them as
# dependencies to the main 'stage_tests' target.
#
# This pattern avoids directory scope issues with add_custom_command.
#
# Usage:
#   pylabhub_register_test_for_staging(TARGET <target_name>)
#
function(pylabhub_register_test_for_staging)
  set(options "")
  set(oneValueArgs "TARGET")
  set(multiValueArgs "")
  cmake_parse_arguments(ARG "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})

  if(NOT ARG_TARGET)
    message(FATAL_ERROR "pylabhub_register_test_for_staging requires a TARGET argument.")
  endif()

  if(NOT TARGET ${ARG_TARGET})
    message(FATAL_ERROR "pylabhub_register_test_for_staging: Target '${ARG_TARGET}' does not exist.")
  endif()

  # Set the output directory for the executable to be inside the staged 'tests' folder.
  # For single-config generators (e.g., Makefiles, Ninja), setting the base
  # RUNTIME_OUTPUT_DIRECTORY is sufficient. For multi-config generators (e.g.,
  # Visual Studio, Xcode), CMake appends a per-configuration subdirectory by
  # default. To override this and ensure a consistent path, we explicitly set the
  # output directory for each configuration.
  if(CMAKE_CONFIGURATION_TYPES)
    # This is a multi-config generator.
    set(output_dir_props "")
    foreach(config ${CMAKE_CONFIGURATION_TYPES})
      string(TOUPPER ${config} config_upper)
      list(APPEND output_dir_props RUNTIME_OUTPUT_DIRECTORY_${config_upper} "${PYLABHUB_STAGING_DIR}/tests")
    endforeach()
    set_target_properties(${ARG_TARGET} PROPERTIES ${output_dir_props})
  else()
    # This is a single-config generator.
    set_target_properties(${ARG_TARGET} PROPERTIES
      RUNTIME_OUTPUT_DIRECTORY "${PYLABHUB_STAGING_DIR}/tests"
    )
  endif()

  # Register this target to a global property so the parent scope can collect it
  set_property(GLOBAL APPEND PROPERTY PYLABHUB_TEST_EXECUTABLES_TO_STAGE ${ARG_TARGET})
endfunction()

