# === Sanitized debug/file prefix mapping (clean, canonical, deterministic) ===
# Place this after project(...) and after your platform detection block.

# Canonicalize a path if provided. If it exists return realpath; else return absolute path.
function(_canon_if_exists out_var in_path)
  if(NOT in_path OR "${in_path}" STREQUAL "")
    set(${out_var} "" PARENT_SCOPE)
    return()
  endif()
  if(EXISTS "${in_path}")
    file(REAL_PATH "${in_path}" _real_path)
    set(${out_var} "${_real_path}" PARENT_SCOPE)
  else()
    get_filename_component(_abs "${in_path}" ABSOLUTE)
    set(${out_var} "${_abs}" PARENT_SCOPE)
  endif()
endfunction()

# Literal "is prefix" check (no regex) — TRUE if candidate == prefix or candidate starts with prefix + "/"
function(_is_under prefix candidate out_var)
  if(NOT prefix OR NOT candidate)
    set(${out_var} FALSE PARENT_SCOPE)
    return()
  endif()
  string(LENGTH "${prefix}" _plen)
  string(LENGTH "${candidate}" _clen)
  if(_plen EQUAL 0 OR _clen LESS _plen)
    set(${out_var} FALSE PARENT_SCOPE)
    return()
  endif()
  string(SUBSTRING "${candidate}" 0 ${_plen} _sub)
  if(NOT _sub STREQUAL "${prefix}")
    set(${out_var} FALSE PARENT_SCOPE)
    return()
  endif()
  if(_clen EQUAL _plen)
    set(${out_var} TRUE PARENT_SCOPE)
    return()
  endif()
  string(SUBSTRING "${candidate}" ${_plen} 1 _next_char)
  if("${_next_char}" STREQUAL "/")
    set(${out_var} TRUE PARENT_SCOPE)
  else()
    set(${out_var} FALSE PARENT_SCOPE)
  endif()
endfunction()

message(STATUS "=============================================================================")
message(STATUS " Setting up sanitization of file and path names for debug information")


# Collect canonical prefixes into parallel lists _paths[] and _origins[]
set(_paths "")
set(_origins "")

# Canonicalize source and binary roots once and reuse canonical values everywhere.
_canon_if_exists(_canon_source "${CMAKE_SOURCE_DIR}")
_canon_if_exists(_canon_binary "${CMAKE_BINARY_DIR}")

message(STATUS "[Sanitize debug information] canonical CMAKE_SOURCE_DIR = ${_canon_source}")
message(STATUS "[Sanitize debug information] canonical CMAKE_BINARY_DIR = ${_canon_binary}")

# Project source and binary roots (use canonical values)
if(_canon_source)
  list(APPEND _paths "${_canon_source}")
  list(APPEND _origins "SOURCE")
endif()

if(_canon_binary)
  list(APPEND _paths "${_canon_binary}")
  list(APPEND _origins "BUILD")
endif()

# CONDA
if(DEFINED ENV{CONDA_PREFIX} AND NOT "$ENV{CONDA_PREFIX}" STREQUAL "")
  _canon_if_exists(_p "$ENV{CONDA_PREFIX}")
  if(_p)
    list(APPEND _paths "${_p}")
    list(APPEND _origins "CONDA")
  endif()
endif()

# TOOLCHAIN (heuristic: two parents above compiler binary)
if(CMAKE_CXX_COMPILER)
  get_filename_component(_cxx_bin "${CMAKE_CXX_COMPILER}" ABSOLUTE)
  get_filename_component(_cxx_parent "${_cxx_bin}" DIRECTORY)
  get_filename_component(_cxx_root "${_cxx_parent}" DIRECTORY)
  if(_cxx_root AND NOT "${_cxx_root}" STREQUAL "")
    _canon_if_exists(_p "${_cxx_root}")
    if(_p)
      list(APPEND _paths "${_p}")
      list(APPEND _origins "TOOLCHAIN")
    endif()
  endif()
endif()

# SYSROOT
if(DEFINED CMAKE_SYSROOT AND NOT "${CMAKE_SYSROOT}" STREQUAL "")
  _canon_if_exists(_p "${CMAKE_SYSROOT}")
  if(_p)
    list(APPEND _paths "${_p}")
    list(APPEND _origins "SYSROOT")
  endif()
endif()

# Implicit include directories (CMake >= 3.20)
if(DEFINED CMAKE_CXX_IMPLICIT_INCLUDE_DIRECTORIES)
  foreach(_inc IN LISTS CMAKE_CXX_IMPLICIT_INCLUDE_DIRECTORIES)
    if(_inc AND NOT _inc STREQUAL "")
      _canon_if_exists(_p "${_inc}")
      if(_p)
        list(APPEND _paths "${_p}")
        list(APPEND _origins "IMPL_INC")
      endif()
    endif()
  endforeach()
endif()

# Candidate HOME (consider later — only add if nothing else under HOME)
if(DEFINED ENV{HOME} AND NOT "$ENV{HOME}" STREQUAL "")
  _canon_if_exists(_home "$ENV{HOME}")
else()
  set(_home "")
endif()

# Deduplicate by path (keep first origin seen)
set(_uniq_paths "")
set(_uniq_origins "")
list(LENGTH _paths _len)
set(_i 0)
while(_i LESS _len)
  list(GET _paths ${_i} _path)
  list(GET _origins ${_i} _orig)
  if(NOT _path IN_LIST _uniq_paths)
    list(APPEND _uniq_paths "${_path}")
    list(APPEND _uniq_origins "${_orig}")
  endif()
  math(EXPR _i "${_i} + 1")
endwhile()
set(_paths ${_uniq_paths})
set(_origins ${_uniq_origins})

# Add HOME only if no other collected path is under HOME (avoid common-parent trap)
if(_home)
  set(_add_home TRUE)
  list(LENGTH _paths _plen)
  set(_j 0)
  while(_j LESS _plen)
    list(GET _paths ${_j} _ptest)
    _is_under("${_home}" "${_ptest}" _u)
    if(_u)
      set(_add_home FALSE)
      break()
    endif()
    math(EXPR _j "${_j} + 1")
  endwhile()
  if(_add_home)
    list(APPEND _paths "${_home}")
    list(APPEND _origins "HOME")
  endif()
endif()

# Optional: filter out system roots like "/" and "/usr"
set(_kept_paths "")
set(_kept_origins "")
list(LENGTH _paths _plen)
set(_i 0)
while(_i LESS _plen)
  list(GET _paths ${_i} _p)
  list(GET _origins ${_i} _o)
  if(NOT _p STREQUAL "/")
    if(NOT _p MATCHES "^/usr(/|$)")
      list(APPEND _kept_paths "${_p}")
      list(APPEND _kept_origins "${_o}")
    endif()
  endif()
  math(EXPR _i "${_i} + 1")
endwhile()
set(_paths ${_kept_paths})
set(_origins ${_kept_origins})

# Build an index list (0..N-1)
set(_indices "")
list(LENGTH _paths _plen)
if(_plen GREATER 0)
  math(EXPR _imax "${_plen} - 1")
  foreach(_ii RANGE 0 ${_imax})
    list(APPEND _indices "${_ii}")
  endforeach()
endif()

# Robust selection-sort indices by path length descending (position-based)
set(_sorted_indices "")
while(_indices)
  set(_best_pos -1)
  set(_best_len -1)

  list(LENGTH _indices _ilen)
  foreach(_pos RANGE 0 ${_ilen})
    if(${_pos} GREATER_EQUAL ${_ilen})
      break()
    endif()
    list(GET _indices ${_pos} _idx_val)   # original index into _paths
    list(GET _paths ${_idx_val} _ppath)
    list(GET _origins ${_idx_val} _oorig)
    string(LENGTH "${_ppath}" _plen)
    # If this is SOURCE, pick it immediately for this iteration
    if(_oorig STREQUAL "SOURCE")
      set(_best_len ${_plen})
      set(_best_pos ${_pos})
      break()
    elseif(_plen GREATER _best_len)
      set(_best_len ${_plen})
      set(_best_pos ${_pos})
    endif()
  endforeach()

  if(_best_pos EQUAL -1)
    break()
  endif()

  # move the chosen value (original index) into _sorted_indices
  list(GET _indices ${_best_pos} _chosen_val)
  list(APPEND _sorted_indices "${_chosen_val}")
  list(REMOVE_AT _indices ${_best_pos})
endwhile()

# message(STATUS "[sorted indices] ${_sorted_indices}")
message(STATUS "[Sanitize debug information] The following directory will be examined:")
foreach(_idx IN LISTS _sorted_indices)
  list(GET _paths ${_idx} _pp)
  list(GET _origins ${_idx} _oo)
  message(STATUS "  - ${_pp}  (origin=${_oo})")
endforeach()
message(STATUS "")

# Build final lists, preferring SOURCE over BUILD when parent/child conflicts exist.
set(_final_paths "")
set(_final_origins "")

foreach(_idx IN LISTS _sorted_indices)
  list(GET _paths ${_idx} _pp)
  list(GET _origins ${_idx} _oo)
  # message(STATUS " ** examining ${_pp} (origin=${_oo})")
  if("${_oo}" STREQUAL "SOURCE")
    # If this is a SOURCE, remove any kept BUILD entries under it, then append SOURCE.
    set(_k 0)
    list(LENGTH _final_paths _klen)
    while(_k LESS _klen)
      list(GET _final_paths ${_k} _kp)
      list(GET _final_origins ${_k} _ko)
      if("${_ko}" STREQUAL "BUILD")
        _is_under("${_pp}" "${_kp}" _u)
        if(_u)
          # remove BUILD entry at position _k and continue (do not increment _k)
          list(REMOVE_AT _final_paths ${_k})
          list(REMOVE_AT _final_origins ${_k})
          list(LENGTH _final_paths _klen)  # recompute length after removal
          continue()
        endif()
      endif()
      math(EXPR _k "${_k} + 1")
    endwhile()

    # append SOURCE after removing BUILD children
    list(APPEND _final_paths "${_pp}")
    list(APPEND _final_origins "${_oo}")
    # message(STATUS " ** added as ${_pp} (origin=${_oo})")
    continue()
  endif()

  # Non-SOURCE candidate: skip it if it's a parent of any already-kept path.
  set(_is_parent FALSE)
  foreach(_kp IN LISTS _final_paths)
    _is_under("${_pp}" "${_kp}" _u2)
    if(_u2)
      set(_is_parent TRUE)
      break()
    endif()
  endforeach()

  if(NOT _is_parent)
    # message(STATUS " ** added as ${_pp} (origin=${_oo})")
    list(APPEND _final_paths "${_pp}")
    list(APPEND _final_origins "${_oo}")
  # else()
    # message(STATUS " ** not added ...")
  endif()
endforeach()

# -----------------------------
# Sanity check: lengths must match
list(LENGTH _final_paths _flen)
list(LENGTH _final_origins _olen)
if(NOT _flen EQUAL _olen)
  message(FATAL_ERROR "[Sanitize debug information] internal error: _final_paths/_final_origins length mismatch: ${_flen} != ${_olen}")
endif()

# Sort final pairs by descending path length (selection)
math(EXPR _flen_1 "${_flen} - 1")
foreach(_i RANGE ${_flen_1})
  list(APPEND _idxs ${_i})
endforeach()
# message(STATUS "[indices generated] ${_idxs}")

# message(STATUS "[Sanitize debug information] The following directory IN THE FINAL LIST:")
# foreach(_idx RANGE ${_flen_1})
#   list(GET _final_paths ${_idx} _pp)
#   list(GET _final_origins ${_idx} _oo)
#   message(STATUS "  - ${_pp}  (origin=${_oo})")
# endforeach()
# message(STATUS "")

set(_emit_order "")
set(_shortest_len -1)

while(_idxs)
  set(_best_pos -1)
  set(_best_len 9999)
  list(LENGTH _idxs _ilen)
  foreach(_pos RANGE 0 ${_ilen})
    if(${_pos} GREATER_EQUAL ${_ilen})
      break()
    endif()
    list(GET _idxs ${_pos} _ival)
    list(GET _final_paths ${_ival} _ipath)
    # message(STATUS " ** currently shortest length is ${_shortest_len}")
    string(LENGTH "${_ipath}" _l)
    # message(STATUS " ** examining ${_ipath}, len is: ${_l}")
    if(_l LESS_EQUAL _best_len AND _l GREATER_EQUAL _shortest_len)
      set(_best_len ${_l})
      set(_best_pos ${_pos})
    endif()
  endforeach()
  
  if(_best_pos EQUAL -1)
    break()
  endif()
  set(_shortest_len ${_best_len})
  
  list(GET _idxs ${_best_pos} _chosen)
  # message(STATUS " ** chosen one is ${_chosen}")

  list(APPEND _emit_order "${_chosen}")
  list(REMOVE_AT _idxs ${_best_pos})
  # message(STATUS "  ** current _emit_order is ${_emit_order}")
  # message(STATUS "  ** current _idxs is ${_idxs}")
endwhile()

list(REVERSE _emit_order)

# message(STATUS "[emit order] ${_emit_order}")
# message(STATUS "[Sanitize debug information] The following directory for emission:")
# foreach(_idx ${_emit_order})
#   list(GET _final_paths ${_idx} _pp)
#   list(GET _final_origins ${_idx} _oo)
#   message(STATUS "  - ${_pp}  (origin=${_oo})")
# endforeach()
# message(STATUS "")

set(_remap_flags "")
foreach(_i ${_emit_order})
  list(GET _final_paths ${_i} _p)
  list(GET _final_origins ${_i} _o)

  if("${_o}" STREQUAL "SOURCE")
    set(_to "SRC")
  elseif("${_o}" STREQUAL "BUILD")
    set(_to "BUILD")
  elseif("${_o}" STREQUAL "CONDA")
    set(_to "CONDA")
  elseif("${_o}" STREQUAL "TOOLCHAIN")
    set(_to "TOOLCHAIN")
  elseif("${_o}" STREQUAL "SYSROOT")
    set(_to "SYSROOT")
  elseif("${_o}" STREQUAL "IMPL_INC")
    set(_to "IMPL_INC")
  else()
    set(_to "HOME")
  endif()

  list(APPEND _remap_flags "-ffile-prefix-map=${_p}=${_to}")
  list(APPEND _remap_flags "-fdebug-prefix-map=${_p}=${_to}")
endforeach()

# Diagnostics and apply flags
if(_remap_flags)
  message(STATUS "[Sanitized debug information] Will pass file/debug prefix map flags:")
  foreach(_f IN LISTS _remap_flags)
    message(STATUS "  ${_f}")
  endforeach()
  if(CMAKE_CXX_COMPILER_ID MATCHES "GNU|Clang")
    add_compile_options(${_remap_flags})
  elseif(MSVC)
    add_compile_options(/FC-)
  endif()
else()
  message(STATUS "[Sanitized debug information] No remap flags generated.")
endif()

message(STATUS "===========================================================================")
message(STATUS "")
