# cmake/assemble_xop.cmake.in
# ------------------------------------------------------------------------------
# This script assembles a standard macOS .xop bundle from a compiled binary.
#
# It is not executed directly but is configured by `run_assemble_xop.cmake`,
# which supplies all the necessary paths and names as `@VARIABLES@`. This script
# performs the file system operations to create the required bundle structure.
# ------------------------------------------------------------------------------
cmake_minimum_required(VERSION 3.18)

message(STATUS "assemble_xop.cmake: starting assembly")
message(STATUS "  MACHO_BINARY_PATH = '@MACHO_BINARY_PATH@'")
message(STATUS "  BUNDLE_DIR        = '@BUNDLE_DIR@'")
message(STATUS "  XOP_BUNDLE_NAME   = '@XOP_BUNDLE_NAME@'")

# Validate required inputs
if(NOT DEFINED MACHO_BINARY_PATH OR NOT DEFINED BUNDLE_DIR OR NOT DEFINED XOP_BUNDLE_NAME)
  message(FATAL_ERROR "assemble_xop.cmake: Required variables are missing.")
endif()

# --- Step 1: Clean up any previous bundle from the build directory ---
# This ensures a fresh build and prevents leftover artifacts from causing issues.
if(EXISTS "@BUNDLE_DIR@")
  message(STATUS "  - Removing old bundle: @BUNDLE_DIR@")
  file(REMOVE_RECURSE "@BUNDLE_DIR@")
endif()

# --- Step 2: Create the standard macOS bundle directory structure ---
# A bundle is just a folder with a specific layout that the OS understands.
#   - Contents/
#     - MacOS/       (for the main executable binary)
#     - Resources/   (for resource files, icons, and localizations)
#       - en.lproj/  (for English-language specific resources)
set(_contents_dir "@BUNDLE_DIR@/Contents")
set(_macos_dir    "${_contents_dir}/MacOS")
set(_resources_dir "${_contents_dir}/Resources")
set(_en_lproj_dir "${_resources_dir}/en.lproj")
file(MAKE_DIRECTORY "${_macos_dir}")
file(MAKE_DIRECTORY "${_en_lproj_dir}")
message(STATUS "  - Created bundle directory structure in @BUNDLE_DIR@")

# --- Step 3: Copy the compiled Mach-O binary into the bundle ---
# The binary is placed inside `Contents/MacOS/` and given a name that matches
# the `CFBundleExecutable` key in the Info.plist.
set(_dest_exec_path "${_macos_dir}/@XOP_BUNDLE_NAME@")
get_filename_component(source_binary_name "@MACHO_BINARY_PATH@" NAME)
set(_temp_dest_path "${_macos_dir}/${source_binary_name}")

message(STATUS "  - Copying binary '@MACHO_BINARY_PATH@' to '${_dest_exec_path}'")
# We copy first, then rename. This is a robust way to handle the copy,
# ensuring the final executable has the exact name required by the bundle.
file(COPY "@MACHO_BINARY_PATH@" DESTINATION "${_macos_dir}")
file(RENAME "${_temp_dest_path}" "${_dest_exec_path}")

# Ensure executable bit on the copied file
if(EXISTS "${_dest_exec_path}")
  execute_process(COMMAND /bin/chmod +x "${_dest_exec_path}")
endif()

# --- Step 4: Place the Info.plist file in the bundle ---
# The Info.plist is the bundle's manifest, containing metadata like its
# identifier, version, and executable name. We use a template that was
# configured by the main CMakeLists.txt.
if(EXISTS "@CONFIGURED_INFO_PLIST@")
    file(COPY "@CONFIGURED_INFO_PLIST@" DESTINATION "${_contents_dir}/")
    message(STATUS "  - Copied pre-configured Info.plist to bundle.")
else()
    message(WARNING "  - CONFIGURED_INFO_PLIST was not provided. Cannot create Info.plist.")
endif()

# --- Step 5: Place the InfoPlist.strings file in the bundle ---
# This file provides localized values for keys in the Info.plist, such as the
# bundle's display name. It's placed in the language-specific resource folder.
if(EXISTS "@INFO_PLIST_STRINGS_SOURCE@")
    file(COPY "@INFO_PLIST_STRINGS_SOURCE@" DESTINATION "${_en_lproj_dir}/")
    message(STATUS "  - Copied InfoPlist.strings to 'en.lproj' resource directory.")
else()
    # Fallback to a minimal version if the source file isn't provided
    file(WRITE "${_en_lproj_dir}/InfoPlist.strings"
        "/* Localized versions of Info.plist keys */\n\n"
        "CFBundleName = \"@XOP_BUNDLE_NAME@\";\n"
        "CFBundleShortVersionString = \"1.0\";\n"
        "CFBundleGetInfoString = \"@XOP_BUNDLE_NAME@ version 1.0\";\n"
    )
    message(STATUS "  - Wrote minimal InfoPlist.strings to bundle.")
endif()

# --- Step 6: Compile the XOP's resource file (.r -> .rsrc) ---
# This is a critical step for Igor Pro XOPs. The `.r` file defines the
# functions, menus, and windows the XOP exposes to Igor. Apple's `Rez` tool
# compiles this into a binary `.rsrc` file, which Igor reads at runtime.
set(REZ_SOURCE_FILE "@REZ_SOURCE_FILE@")
if(EXISTS "${REZ_SOURCE_FILE}")
  find_program(REZ_EXECUTABLE Rez)
  if(REZ_EXECUTABLE)
    set(rez_output_rsrc "${_resources_dir}/@XOP_BUNDLE_NAME@.rsrc")

    # Build the include path arguments for Rez
    # This allows the .r file to `#include` headers from the XOP Toolkit.
    set(rez_args "") # Must be initialized as an empty list for `list(APPEND)`
    set(rez_include_dirs "@R_INCLUDE_DIRS_LIST@")
    if(NOT "${rez_include_dirs}" STREQUAL "")
      string(REPLACE ";" " " _inc_dirs_list_str "${rez_include_dirs}")
      foreach(dir IN LISTS _inc_dirs_list_str)
        list(APPEND rez_args "-I" "${dir}")
      endforeach()
    endif()

    message(STATUS "  - Compiling resource file with Rez: ${REZ_SOURCE_FILE}")
    # The `-useDF` flag is essential. It tells Rez to write the compiled
    # resources to the file's "data fork," which is the standard for modern
    # macOS. Without it, Rez uses the legacy "resource fork," which is often
    # lost during file copy operations, leading to an empty .rsrc file and
    # a "logical end-of-file" error in Igor.
    execute_process(
      COMMAND ${REZ_EXECUTABLE} ${rez_args} -useDF -o "${rez_output_rsrc}" "${REZ_SOURCE_FILE}"
      RESULT_VARIABLE rez_result
      ERROR_VARIABLE rez_error
    )

    if(rez_result EQUAL 0)
      message(STATUS "  - Created resource file: ${rez_output_rsrc}")
    else()
      message(WARNING "Rez failed to compile resource file. Error: ${rez_error}")
    endif()
  else()
      message(WARNING "  - Rez compiler not found in PATH. Cannot compile .r file.")
  endif()
else()
    message(STATUS "  - No .r file found, skipping resource compilation.")
endif()

message(STATUS "assemble_xop.cmake: assembly complete.")