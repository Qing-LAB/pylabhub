/*******************************************************************************
 * @file FileLock.cpp
 * @brief Implementation of a cross-platform RAII file lock.
 *
 * **Design Philosophy**
 * `FileLock` provides a robust, cross-platform, RAII-style mechanism for
 * managing inter-process file locks. It is a critical component for ensuring
 * the integrity of shared resources like configuration files.
 *
 * 1.  **RAII (Resource Acquisition Is Initialization)**: The lock is acquired in
 *     the constructor and automatically released in the destructor. This prevents
 *     leaked locks, even in the presence of exceptions.
 * 2.  **Cross-Platform Abstraction**: The class provides a unified interface over
 *     divergent platform-specific locking primitives:
 *     - **POSIX**: Uses `flock()` on a dedicated `.lock` file. This is a widely
 *       supported and robust advisory locking mechanism.
 *     - **Windows**: Uses `LockFileEx()` on a handle to a dedicated `.lock` file.
 * 3.  **Lock File Strategy**: A separate lock file (e.g., `config.json.lock` for
 *     `config.json`) is used instead of locking the target file directly. This
 *     avoids issues where file content operations might interfere with the lock
 *     itself and simplifies the implementation.
 * 4.  **Blocking and Non-Blocking Modes**: The lock can be acquired in either
 *     `Blocking` or `NonBlocking` mode. The `NonBlocking` mode allows for a
 *     "fail-fast" policy, which is used by `JsonConfig` to avoid deadlocks or
 *     long waits if another process holds the lock.
 * 5.  **Movability**: The class is movable but not copyable, allowing ownership
 *     of a lock to be efficiently transferred (e.g., returned from a factory
 *     function) while preventing accidental duplication.
 *
 * **Thread Safety**
 * A `FileLock` instance is designed to be owned and used by a single thread.
 * It is not safe to call methods on the same `FileLock` object from multiple
 * threads concurrently. However, it is safe to create, move, and destroy
 * `FileLock` objects across different threads.
 ******************************************************************************/

#include "utils/FileLock.hpp"
#include "utils/Logger.hpp"
#include "utils/PathUtil.hpp"

#include <filesystem>
#include <string>
#include <system_error>
#include <utility>

#if defined(_WIN32)
#include <sstream>
#include <windows.h>
#else
#include <fcntl.h>
#include <sys/file.h>
#include <sys/stat.h>
#include <unistd.h>
#endif

namespace pylabhub::utils
{

// --- Pimpl Definition ---

// The private implementation of the FileLock.
// All state is held here to provide ABI stability for the public FileLock class.
struct FileLockImpl
{
    std::filesystem::path path; // The original path for which a lock is requested.
    bool valid = false;         // True if the lock is currently held.
    std::error_code ec;         // Stores the last error if `valid` is false.

#if defined(_WIN32)
    void *handle = nullptr; // The Windows file handle (HANDLE) for the .lock file.
#else
    int fd = -1; // The POSIX file descriptor for the .lock file.
#endif
};

// Forward declaration for the private locking function.
static void open_and_lock(LockMode mode, FileLockImpl *pImpl);

// Helper: build lockfile path for a given target path.
// Lock name policy: <parent>/<filename>.lock
static std::filesystem::path make_lock_path(const std::filesystem::path &target)
{
    std::filesystem::path parent = target.parent_path();
    if (parent.empty())
        parent = ".";
    std::string fname = target.filename().string();
    if (fname.empty() || fname == "." || fname == "..")
    {
        // Fallback if target is a directory, path ends with a separator, or is "." or "..".
        // Use the parent's name as a basis.
        fname = parent.filename().string();
        if (fname.empty() || fname == "." || fname == "..")
        {
            // Ultimate fallback for root or other unusual paths.
            fname = "file";
        }
    }
    return parent / (fname + ".lock");
}

// ---------------- FileLock implementation ----------------

// Constructor: attempts to open and lock the file based on the specified mode.
FileLock::FileLock(const std::filesystem::path &path, LockMode mode)
    : pImpl(std::make_unique<FileLockImpl>())
{
    // Delegate all logic to the private implementation.
    pImpl->path = path;
    open_and_lock(mode, pImpl.get());
}

// Move constructor: transfers ownership of the lock from another FileLock instance.
// The default implementation generated by the compiler is correct because the
// class's only member, `std::unique_ptr`, has well-defined move semantics.
FileLock::FileLock(FileLock &&) noexcept = default;

// Move assignment operator: releases the current lock and takes ownership of another.
// The default implementation is correct. `std::unique_ptr`'s move assignment
// operator automatically handles releasing the old resource before acquiring the new one.
FileLock &FileLock::operator=(FileLock &&) noexcept = default;

// Destructor: ensures the lock is released when the object goes out of scope.
FileLock::~FileLock()
{
    // A moved-from FileLock will have a null pImpl. Its destructor is a no-op.
    if (!pImpl || !pImpl->valid)
    {
        return;
    }

    // At this point, pImpl->valid is true, so we hold a valid lock and handle/fd.
    // Release lock and close file/handle. Ignore errors during this best-effort cleanup,
    // as there is little a caller can do about a failure during destruction.
#if defined(_WIN32)
    OVERLAPPED ov = {};
    UnlockFileEx((HANDLE)pImpl->handle, 0, MAXDWORD, MAXDWORD, &ov);
    CloseHandle((HANDLE)pImpl->handle);
    pImpl->handle = nullptr; // Not strictly necessary, but good practice.
#else
    flock(pImpl->fd, LOCK_UN);
    ::close(pImpl->fd);
    pImpl->fd = -1; // Not strictly necessary, but good practice.
#endif
}

bool FileLock::valid() const noexcept
{
    // A default-constructed or moved-from object will have a null pImpl.
    return pImpl && pImpl->valid;
}

std::error_code FileLock::error_code() const noexcept
{
    // Return a default-constructed (empty) error code if the object is not initialized.
    return pImpl ? pImpl->ec : std::error_code();
}

// Private helper that performs the actual locking logic on the Impl struct.
static void open_and_lock(LockMode mode, FileLockImpl *pImpl)
{
    if (!pImpl)
        return;

    // Reset state in Impl for the new lock attempt.
    pImpl->valid = false;
    pImpl->ec.clear();

    auto lockpath = make_lock_path(pImpl->path);

    // Ensure the directory for the lock file exists before trying to create the file.
    // This is wrapped in a try/catch as filesystem operations can throw exceptions
    // (e.g., on permission errors not reported by the error_code overload).
    try
    {
        auto parent_dir = lockpath.parent_path();
        if (!parent_dir.empty())
        {
            std::error_code create_ec;
            std::filesystem::create_directories(parent_dir, create_ec);
            if (create_ec)
            {
                pImpl->ec = create_ec;
                LOGGER_WARN("FileLock: create_directories failed for {} err={}",
                            parent_dir.string(), create_ec.message());
                pImpl->valid = false;
                return;
            }
        }
    }
    catch (const std::exception &e)
    {
        pImpl->ec = std::make_error_code(std::errc::io_error);
        LOGGER_WARN("FileLock: create_directories threw an exception for {}: {}",
                    lockpath.parent_path().string(), e.what());
        pImpl->valid = false;
        return;
    }

#if defined(_WIN32)
    // Convert to long path for Windows API calls to handle paths > MAX_PATH.
    std::wstring lockpath_w = win32_to_long_path(lockpath);

    // Open or create the lock file. We allow sharing at the file system level
    // because we will use LockFileEx to enforce an exclusive lock.
    HANDLE h = CreateFileW(
        lockpath_w.c_str(), GENERIC_READ | GENERIC_WRITE,
        // Allow other processes to open the file. The OS-level lock provided
        // by LockFileEx is what guarantees exclusivity, not the file sharing mode.
        FILE_SHARE_READ | FILE_SHARE_WRITE, nullptr, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, nullptr);

    if (h == INVALID_HANDLE_VALUE)
    {
        pImpl->ec = std::error_code(GetLastError(), std::system_category());
        // log using new logger API
        LOGGER_WARN("FileLock: CreateFileW failed for {} err={}", lockpath.string(),
                    pImpl->ec.value());
        pImpl->handle = nullptr;
        pImpl->valid = false;
        return;
    }

    // Prepare flags: exclusive lock; optionally fail immediately for non-blocking mode.
    DWORD flags = LOCKFILE_EXCLUSIVE_LOCK;
    if (mode == LockMode::NonBlocking)
        flags |= LOCKFILE_FAIL_IMMEDIATELY;

    // The OVERLAPPED struct is required for LockFileEx, even for synchronous operations.
    // We lock the entire file by specifying a very large range (MAXDWORD, MAXDWORD).
    OVERLAPPED ov = {};
    BOOL ok = LockFileEx(h, flags, 0, MAXDWORD, MAXDWORD, &ov);
    if (!ok)
    {
        DWORD err = GetLastError();
        pImpl->ec = std::error_code(static_cast<int>(err), std::system_category());
        LOGGER_WARN("FileLock: LockFileEx failed for {} err={}", lockpath.string(), err);
        CloseHandle(h);
        pImpl->handle = nullptr;
        pImpl->valid = false;
        return;
    }

    // Success
    pImpl->handle = reinterpret_cast<void *>(h);
    pImpl->valid = true;
    pImpl->ec.clear();
    return;

#else
    // POSIX implementation
    int flags = O_CREAT | O_RDWR;
    // Mode 0666 so that file creation honors the process's umask.
    int fd = ::open(lockpath.c_str(), flags, 0666);
    if (fd == -1)
    {
        pImpl->ec = std::error_code(errno, std::generic_category());
        LOGGER_WARN("FileLock: open failed for {} err={}", lockpath.string(),
                    pImpl->ec.message());
        pImpl->fd = -1;
        pImpl->valid = false;
        return;
    }

    // Prepare flags for flock(). LOCK_EX requests an exclusive lock.
    // LOCK_NB makes the call non-blocking.
    int op = LOCK_EX;
    if (mode == LockMode::NonBlocking)
        op |= LOCK_NB;

    if (flock(fd, op) != 0)
    {
        pImpl->ec = std::error_code(errno, std::generic_category());
        LOGGER_WARN("FileLock: flock failed for {} err={}", lockpath.string(),
                    pImpl->ec.message());
        ::close(fd);
        pImpl->fd = -1;
        pImpl->valid = false;
        return;
    }

    // Success
    pImpl->fd = fd;
    pImpl->valid = true;
    pImpl->ec.clear();
    return;
#endif
}

} // namespace pylabhub::utils
