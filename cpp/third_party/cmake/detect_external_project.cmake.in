# detect_external_project.cmake.in
# expects the following variables to be set:
#   PACKAGE_NAME
#   PREREQ_INSTALL_DIR
#   PACKAGE_BINARY_DIR
#   LIB_PATTERNS
#   HEADER_SOURCE_PATTERNS
#   STABLE_BASENAME

message(STATUS "detect: PACKAGE_NAME=${PACKAGE_NAME}")
message(STATUS "detect: PREREQ_INSTALL_DIR=${PREREQ_INSTALL_DIR}")
message(STATUS "detect: PACKAGE_BINARY_DIR=${PACKAGE_BINARY_DIR}")

set(_found_lib "")

# --- 1) try patterns under install/lib ---
if(DEFINED LIB_PATTERNS AND LIB_PATTERNS)
  foreach(_pat IN LISTS LIB_PATTERNS)
    # Use glob to expand candidate matches under install/lib
    file(GLOB _matches RELATIVE "${PREREQ_INSTALL_DIR}/lib" "${PREREQ_INSTALL_DIR}/lib/${_pat}" )
    foreach(_m IN LISTS _matches)
      if(NOT _found_lib)
        set(_found_lib "${PREREQ_INSTALL_DIR}/lib/${_m}")
      endif()
    endforeach()
    if(_found_lib)
      break()
    endif()
  endforeach()
endif()

# --- 2) fallback: scan binary dir for common libs (first match wins) ---
if(NOT _found_lib)
  file(GLOB _bin_libs
    "${PACKAGE_BINARY_DIR}/*/*.a"
    "${PACKAGE_BINARY_DIR}/*/*.so"
    "${PACKAGE_BINARY_DIR}/*/*.dylib"
    "${PACKAGE_BINARY_DIR}/*/*.lib"
    "${PACKAGE_BINARY_DIR}/*.a"
    "${PACKAGE_BINARY_DIR}/*.so"
    "${PACKAGE_BINARY_DIR}/*.dylib"
    "${PACKAGE_BINARY_DIR}/*.lib"
  )
  if(_bin_libs)
    list(GET _bin_libs 0 _found_lib)
  endif()
endif()

# --- 3) relaxed search under install/lib by name ---
if(NOT _found_lib)
  message(WARNING "detect: unable to find library artifact for ${PACKAGE_NAME} using patterns. Attempting relaxed search under install/lib")
  file(GLOB _relaxed "${PREREQ_INSTALL_DIR}/lib/*${PACKAGE_NAME}*.*")
  if(_relaxed)
    list(GET _relaxed 0 _found_lib)
  endif()
endif()

if(NOT _found_lib)
  message(FATAL_ERROR "detect: could not discover built artifact for ${PACKAGE_NAME}. Checked install and binary dirs.")
endif()

message(STATUS "detect: discovered artifact: ${_found_lib}")

# determine extension and stable path
get_filename_component(_found_name "${_found_lib}" NAME)
# Old: get_filename_component(_found_ext "${_found_lib}" EXT)
# New: Robustly determine extension
set(_found_ext "")
string(REGEX MATCH "\\.a$" _match_a "${_found_lib}")
string(REGEX MATCH "\\.so$" _match_so "${_found_lib}")
string(REGEX MATCH "\\.dylib$" _match_dylib "${_found_lib}")
string(REGEX MATCH "\\.lib$" _match_lib "${_found_lib}")

if(_match_a)
  set(_found_ext ".a")
elseif(_match_so)
  set(_found_ext ".so")
elseif(_match_dylib)
  set(_found_ext ".dylib")
elseif(_match_lib)
  set(_found_ext ".lib")
else()
  # Fallback to CMake's default behavior if none match, or error
  get_filename_component(_found_ext "${_found_lib}" EXT)
  message(WARNING "detect: Unknown library extension for ${_found_lib}. Falling back to default get_filename_component EXT behavior.")
endif()
set(_stable_lib_path "${PREREQ_INSTALL_DIR}/lib/${STABLE_BASENAME}${_found_ext}")

# copy/rename artifact to stable path (overwrite if exists)
# Use COPY then RENAME as before
file(COPY "${_found_lib}" DESTINATION "${PREREQ_INSTALL_DIR}/lib")
file(RENAME "${PREREQ_INSTALL_DIR}/lib/${_found_name}" "${_stable_lib_path}" )

message(STATUS "detect: wrote stable artifact to ${_stable_lib_path}")

# -------------------------------------------------------------------------
# Headers: copy patterns into include/<PACKAGE_NAME>, but avoid copying a
# source that already lives inside that destination (prevents self-copying).
# If the header source is a directory, copy its children (not the directory
# itself) to avoid adding an extra nesting layer each run.
# -------------------------------------------------------------------------
if(DEFINED HEADER_SOURCE_PATTERNS AND HEADER_SOURCE_PATTERNS)
  set(_hdr_dir "${PREREQ_INSTALL_DIR}/include/${PACKAGE_NAME}")
  file(MAKE_DIRECTORY "${_hdr_dir}")

  # Compute canonical absolute path of destination for robust checks
  get_filename_component(_hdr_dir_abs "${_hdr_dir}" ABSOLUTE)

  foreach(_hp_pattern IN LISTS HEADER_SOURCE_PATTERNS)
    set(_found_header_source FALSE)

    # Try candidate 1: glob for pattern under PACKAGE_BINARY_DIR
    file(GLOB _header_sources_bin "${PACKAGE_BINARY_DIR}/${_hp_pattern}")
    if(_header_sources_bin)
      foreach(_source_path IN LISTS _header_sources_bin)
        get_filename_component(_source_path_abs "${_source_path}" ABSOLUTE)
        # Avoid copying into itself
        if(NOT _source_path_abs STREQUAL "${_hdr_dir_abs}" AND NOT _source_path_abs MATCHES "^${_hdr_dir_abs}/")
          if(IS_DIRECTORY "${_source_path}")
            file(GLOB _children RELATIVE "${_source_path}" "${_source_path}/*")
            foreach(_child IN LISTS _children)
              file(COPY "${_source_path}/${_child}" DESTINATION "${_hdr_dir}")
            endforeach()
          else()
            file(COPY "${_source_path}" DESTINATION "${_hdr_dir}")
          endif()
          message(STATUS "detect: copied headers from ${_source_path} (from bin) -> ${_hdr_dir}")
          set(_found_header_source TRUE)
        endif()
      endforeach()
      if(_found_header_source)
        continue() # Move to next _hp_pattern if any were found
      endif()
    endif()

    # Try candidate 2: glob for pattern under PREREQ_INSTALL_DIR
    file(GLOB _header_sources_install "${PREREQ_INSTALL_DIR}/${_hp_pattern}")
    if(_header_sources_install)
      foreach(_source_path IN LISTS _header_sources_install)
        get_filename_component(_source_path_abs "${_source_path}" ABSOLUTE)
        # Avoid copying into itself
        if(NOT _source_path_abs STREQUAL "${_hdr_dir_abs}" AND NOT _source_path_abs MATCHES "^${_hdr_dir_abs}/")
          if(IS_DIRECTORY "${_source_path}")
            file(GLOB _children2 RELATIVE "${_source_path}" "${_source_path}/*")
            foreach(_child IN LISTS _children2)
              file(COPY "${_source_path}/${_child}" DESTINATION "${_hdr_dir}")
            endforeach()
          else()
            file(COPY "${_source_path}" DESTINATION "${_hdr_dir}")
          endif()
          message(STATUS "detect: copied headers from ${_source_path} (from install) -> ${_hdr_dir}")
          set(_found_header_source TRUE)
        endif()
      endforeach()
      if(_found_header_source)
        continue() # Move to next _hp_pattern if any were found
      endif()
    endif()

    if(NOT _found_header_source)
      message(WARNING "detect: header pattern '${_hp_pattern}' not found for ${PACKAGE_NAME}; skipping.")
    endif()
  endforeach()
else()
  message(STATUS "detect: no HEADER_SOURCE_PATTERNS provided for ${PACKAGE_NAME}; skipping header copy.")
endif()

# -------------------------------------------------------------------------
# Generate a basic CMake package config file so that other CMake projects
# (like libzmq, when built via add_subdirectory) can find this prerequisite.
# -------------------------------------------------------------------------
set(_config_dir "${PREREQ_INSTALL_DIR}/lib/cmake/${PACKAGE_NAME}")
set(_config_file "${_config_dir}/${PACKAGE_NAME}-config.cmake")
# Use a unique target name in the generated file to avoid conflicts.
set(_target_name_in_config "${PACKAGE_NAME}::${PACKAGE_NAME}")

file(MAKE_DIRECTORY "${_config_dir}")

# Use relative paths from the config file's location to the include/lib dirs.
# This makes the generated package relocatable.
set(_rel_include_dir "\${CMAKE_CURRENT_LIST_DIR}/../../../include")
set(_rel_lib_path "\${CMAKE_CURRENT_LIST_DIR}/../../../lib/${STABLE_BASENAME}")

set(_config_content "
# Generated by pylabhub build system
if(NOT TARGET ${_target_name_in_config})
  add_library(${_target_name_in_config} UNKNOWN IMPORTED)
  set_target_properties(${_target_name_in_config} PROPERTIES
    IMPORTED_LOCATION \"${_rel_lib_path}\"
    INTERFACE_INCLUDE_DIRECTORIES \"${_rel_include_dir}\"
  )
endif()
")

file(WRITE "${_config_file}" "${_config_content}")
message(STATUS "detect: wrote CMake package config to ${_config_file}")


# write stamp file
file(WRITE "${PREREQ_INSTALL_DIR}/${PACKAGE_NAME}-stamp.txt" "OK\n")
message(STATUS "detect: wrote stamp ${PREREQ_INSTALL_DIR}/${PACKAGE_NAME}-stamp.txt")
